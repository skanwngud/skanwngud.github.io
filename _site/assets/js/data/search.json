[
  
  {
    "title": "숫자와 문자가 혼합 된 문자열에서 숫자만 찾기",
    "url": "/posts/find-number-in-string/",
    "categories": "",
    "tags": "python, snippet",
    "date": "2023-03-20 00:00:00 +0900",
    





    
    "snippet": "Summarya_1, 100_a 등과 같은 문자 + 숫자 조합의 문자열에서 숫자 정보만 반환한다.Source Codeimport reint(''.join(re.findall('\\d', string)))Explanationimport rere 라이브러리를 임포트해준다.re 라이브러니는 정규화 관련 함수들이 들어있는 라이브러리이다.짧은 한 줄의 코드를 굳...",
    "content": "Summarya_1, 100_a 등과 같은 문자 + 숫자 조합의 문자열에서 숫자 정보만 반환한다.Source Codeimport reint(''.join(re.findall('\\d', string)))Explanationimport rere 라이브러리를 임포트해준다.re 라이브러니는 정규화 관련 함수들이 들어있는 라이브러리이다.짧은 한 줄의 코드를 굳이 구분을 짓자면 re.findall('\\d', string), ''.join(), int() 이렇게 3개로 나눌 수 있는데,re.findall('\\d', string)이 코드는 string 이라는 문자열 안에 있는 숫자 ('\\d') 를 전부 찾아내 리스트 형태로 반환한다.''.join()괄호 안에 있는 iterable 한 객체들을 빈칸없이 전부 모아서 합쳐준다.int()str 타입인 숫자만 들어있는 문자열을 int 타입으로 바꿔준다.나는 주로 해당 코드를 sorted() 함수와 엮어 문자와 숫자가 결합 된 파일명들의 리스트들을 정렬하는 데에 사용한다.Resultimport retest_list = ['a_1', 'a_2', 'a_10', '11_a', '2a_', '100', 'a_200']sorted_list_1 = sorted(test_list)sorted_list_2 = sorted(test_list, key=lambda x: int(''.join(re.findall('\\d', x))))print(sorted_list_1)print(sorted_list_2)# 결과# ['100', '11_a', '2a_', 'a_1', 'a_10', 'a_2', 'a_200']# ['a_1', 'a_2', '2a_', 'a_10', '11_a', '100', 'a_200']"
  },
  
  {
    "title": "UML",
    "url": "/posts/UML-1/",
    "categories": "UML",
    "tags": "uml",
    "date": "2023-03-20 00:00:00 +0900",
    





    
    "snippet": "UML  소스코드를 도형 및 화살표 등으로 기능을 설명함종류  정적인 부분          단순 코드 나열하여 기능 설명        동적인 부분          sequence diagram, 소스코드의 flow 를 설명함      구조Class Diagram (정적)  Life Ccle 을 관리하면 UML 화살표 상에서 검은색으로 칠함  Assoc...",
    "content": "UML  소스코드를 도형 및 화살표 등으로 기능을 설명함종류  정적인 부분          단순 코드 나열하여 기능 설명        동적인 부분          sequence diagram, 소스코드의 flow 를 설명함      구조Class Diagram (정적)  Life Ccle 을 관리하면 UML 화살표 상에서 검은색으로 칠함  Association (상관 관계)          양방향      단반향      Recursive (design pattern 등에서 자주 사용)      Inner class; a 클래스가 b 클래스 안에서 선언 되어 사용      Dependancy; a 클래스의 내부의 함수에서 b 클래스가 사용 됨 (a 클래스의 함수가 사라지면 b 클래스 사라짐)      Aggregation; a 클래스 내부에서 b 클래스가 선언 되었지만 생명주기를 관리하진 않음      Composition;      Genealization (일반화, 상속); a 클래스를 b 클래스를 상속하여 사용      Realization (실체화, 구현); a 클래스에서는 인터페이스만 선언하고 b 클래스에서 a 클래스를 상속하여 구현      Sequence Diagram (동적)  유닛 테스트unittest  정형화 된 코드pytest  정형화 되어있지 않은 알고리즘 같은 코드 등에 주로 사용"
  },
  
  {
    "title": "컴퓨터 구조 (3)",
    "url": "/posts/computer-structure-3/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-03-16 00:00:00 +0900",
    





    
    "snippet": "실수를 표현하는 방법고정소수점 표현법  2진 소수점의 위치를 임의로 정하는 방법  4비트가 있다고했을 때 2비트는 소수점의 오른쪽에 있는 분수를 표현하고 2비트는 왼쪽에 있는 숫자들을 표현하는데 쓸 수 있다.          2비트 = 분수, 2비트 = 정수 표시              정수를 나타내는 비트는 동일하며 분수를 나타내는 비트는 2의 음의...",
    "content": "실수를 표현하는 방법고정소수점 표현법  2진 소수점의 위치를 임의로 정하는 방법  4비트가 있다고했을 때 2비트는 소수점의 오른쪽에 있는 분수를 표현하고 2비트는 왼쪽에 있는 숫자들을 표현하는데 쓸 수 있다.          2비트 = 분수, 2비트 = 정수 표시              정수를 나타내는 비트는 동일하며 분수를 나타내는 비트는 2의 음의 거듭제곱처럼 나타낸다\\[2^1 + 2^0 \\, . 2^{-1} + 2^{-2}\\]              해당 방법은 실수값을 표현하기 위해 필요한 비트가 너무 많기 때문에 범용 컴퓨터에서 사용하는 경우는 드물지만, 디지털 신호 처리 장치 (DSP; Digital Signal Processor) 에선 종종 사용.부동소수점 표현법  넓은 범위의 실수를 2진수로 표현하기 위해 과학적 표기법을 적용.  수를 해석하는 새로운 방법을 도입해서 큰 범위의 수를 표현.          가수mantissa 와 지수exponent 를 통해 표현.    \\[1.2 * 10^{-3} \\; (1.2가 \\, 가수,\\, 10^{-3}가 \\, 지수)\\]    2진수의 지수의 밑은 항상 2로 고정.\\[2^0.2^{-1}\\,* (2^{...2+1+0})\\]  해당 방법은 0을 표현하는 방법이 4가지나 되는 0 표기 중복이 발생하여 비트 낭비가 심하며 모든 수를 표현할 수 없다는 문제를 갖고 있다.IEEE 부동소수점 수 표준  가수와 지수에 대해 각각 부호 비트를 사용.  지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있음.  낭비 되는 비트 조합을 최소화하고 반올림을 쉽게하기 위해 여러 가지 트릭을 사용.          정규화normalization ; 가수를 조정해서 맨 앞에 0 이 없게 만드는 것. (이를 위해서 지수도 조정해야함.)      DEC 에서 고안한 가수의 맨 왼쪽 비트가 1 이란 사실을 알고 있으므로 이를 생략하는 방법.        기본정밀도single precision 은 32비트를 사용하며 7비트 정밀도로 $10^{38}$ 의 범위를 표현 가능.          31 번째 (제일 왼쪽) 비트 : S (가수에 대한 부호)      30 ~ 23 비트 : 지수      22 ~ 0 (제일 오른쪽) 비트 : 가수        2배 정밀도double precision 은 64비트를 사용하며 15비트 정밀도로 $10^{308}$ 의 범위를 표현 가능.          63 번째 (제일 왼쪽) 비트 : S (가수에 대한 부호)      62 ~ 52 비트 : 지수      51 ~ 32 (상위 20) 비트 : 가수      31 ~ 0 (하위 32) 비트 : 가수      2진수를 표현하는 다양한 방법BCD  10진수를 표현할 때 4비트를 사용.  12 라는 수를 표현할 때 2진수는 $1100$ 이지만 BCD 로는 $0001$ $0010$ 으로 표현.          앞의 4비트는 십의 자리를 뒤의 4비트는 일의 자리를 표현        디스플레이나 가속도 센서등이 BCD 를 사용하지만 낭비 되는 비트가 너무 많아 현대에는 잘 쓰이지 않음.8진 표현법  밑base number 가 8 ($2^3$) 인 진법.  2진수 비트들을 3그룹으로 묶어서 표현한다.          e.g. $10010111000101100$ 을 표현할 때 3그룹 씩 묶어서 $100$ $101$ $110$ $001$ $010$ $100$ 으로 나눈 후 각자의 수를 계산하여 (4 5 6 1 2 4) 이어 붙인다. → $456124$        아직도 쓰이긴하지만 과거처럼 널리 쓰이진 않음.16진 표현법  밑base number 가 16 ($2^4$) 인 진법.  2진수 비트들을 4그룹으로 표현한다.  최근 컴퓨터 내부가 8비트의 배수를 사용해 만들기 때문.  8의 배수는 4 로는 균일하게 나눠지지만 3 으로는 균일하게 나눠지지 않는다.  16 진수는 0 ~ 9 와 $abcdef$ 까지 사용.          e.g. $11010011111111000001$ 을 표현할 때 4그룹씩 묶어서 $1101$ $0011$ $1111$ $1100$ $0001$ 으로 나눈 후 각자의 수를 계산한다.      $1111$ 은 16 이 되는데 16진수에서 16은 $f$ 로 표현한다.      "
  },
  
  {
    "title": "컴퓨터 구조 (2)",
    "url": "/posts/computer-structure-2/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-03-15 00:00:00 +0900",
    





    
    "snippet": "비트를 사용해 정수를 표현하기정수 표현실생활의 우리가 주로 사용하고 있는 수는 10 진수demical number이다.0 ~ 9 까지를 한 자리에 나타낼 수 있으며  9를 넘는 수는 10 을 곱하여 다시 시작한다.이때 자릿수가 커짐에 따라 10 의 거듭제곱으로 커지게 되며, 지수 부분이 적용 될 밑수base-number 가 10 이기 때문에 10진수라...",
    "content": "비트를 사용해 정수를 표현하기정수 표현실생활의 우리가 주로 사용하고 있는 수는 10 진수demical number이다.0 ~ 9 까지를 한 자리에 나타낼 수 있으며  9를 넘는 수는 10 을 곱하여 다시 시작한다.이때 자릿수가 커짐에 따라 10 의 거듭제곱으로 커지게 되며, 지수 부분이 적용 될 밑수base-number 가 10 이기 때문에 10진수라는 이름이 붙여졌다.이와 마찬가지로 2진수는 0 ~ 1 까지를 한 자리에 나타낼 수 있는 셈법이며 1 을 초과하는 수를 나타낼 땐 2 를 곱하여 다시 시작한다.자릿수가 바뀔 때마다 2 의 거듭제곱순으로 커지게 되며, 밑수가 2 이기 때문에 2 진수라는 이름이 붙었다.  10진수: \\(... 10^5 + 10^4 + 10^3 + 10^2 + 10^1 + 10^0\\)  2진수: \\(... 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0\\)\\(5,028\\) 이라는 수를 표현할 때,10 진수는 \\(5 * 10^3 + 0 * 10^2 + 2 * 10^1 + 8 * 10^0\\)2 진수는 $1 * 2^{12} + 0 * 2^{11} + 0 * 2^{10} + 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 0 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0$10 진수로는 네 자리, 2 진수로는 13자리 (13bit) 가 된다.각 진법의 숫자 개수는 표현할 수 있는 값의 범위를 결정하는데 0 ~ 99 사이의 100가지 다른 수는 10 진수 숫자 2개로 표현 가능하다.마찬가지로 2 진수에서도 비트의 개수로 표현할 수 있는 값의 범위를 정하는데, 예를 들면 2 비트는 0 ~ 3 까지의 수를 표현할 수 있다.2 진수에서 가장 오른쪽에 있는 비트는 가장 작은 유효 비트 (LSB; Least Significant Bit),가장 왼쪽에 있는 비트는 가장 큰 유효 비트 (MSB; Most Significant Bit) 라고 한다.LSB 가 변경 되면 숫자가 가장 적게 변화하고 MSB 가 변경 되면 숫자가 가장 크게 변화하기 때문이다.위에서 본 $5,028$ 는 13bit 라는 것을 알았는데, 이를 16비트 2진수로 표현하면$0 0 0 1 0 0 1 1 \\, 1 0 1 0 0 1 0 0$ 로 표현 할 수 있는데, 이 때 16 자리만큼 채우기 위해 앞에 0 을 붙이는 것을 리딩 제로leading zero 라고 한다.$05,028$ 과 비슷한 의미이며 컴퓨터는 메모리를 할당할 때 미리 정해진 수의 비트를 한 덩어리로 사용하도록 만들어졌기 때문이다. (이 덕분에 어떤 값을 표현하는데 필요한 최소한의 비트 수보다 더 많은 비트를 추가할 수 있다.)2진수 덧셈2 진수의 덧셈은 10 진수의 덧셈과 비슷하게 LSM 부터 MSB 쪽으로 연산하며 결과가 1보다 크면 1을 다음 자리로 올린다.예를 들면 $1 1$ 과 $1 0$ 의 덧셈은 $1 0 1$ 이 된다.이를 10 진수로 풀이해보면 $1 1$ 은 10 진수로 $(1 * 2^1) + (1 * 2^0) = 3$ 이고 $1 0$ 은 $(1 * 2^1) + (0 * 2^0) = 2$ 이기 때문에 $5$ 가 된다.$5$ 을 2 진수로 표현하면 $(1 * 2^2) + (0 * 2^1) + (1 * 2^0) = 5$ 가 된다.2 진 덧셈을 논리연산으로 풀이하면 다음과 같다.            A      B      A AND B      A + B      A XOR B      A      B                  0      0      0      00      0      0      0              0      1      0      01      1      0      1              1      0      0      10      1      1      0              1      1      1      10      0      1      1      A 와 B 의 합연산은 A XOR B 의 값과 같으며 1, 1 인 경우에 1 XOR 1 이 0 인데 이는 두 비트를 더한 결과에서 원래의 위치에 넣을 값과 같다.  비트의 덧셈 연산 중 MSB 에서 올림이 발생했을 때, 오버플로over flow 가 발생한다.음수 표현부호비트 표기법특정한 개수의 비트가 있을 때 MSB 를 부호로 표현한다.0 일 때 양수, 1 일 때 음수.$0001(+1) + 1001(-1)$ 을 계산하면 $1010(-2)$ 이 된다.우리가 의도한 바는 $(+1) + (-1) = 0$ 이 되는 것이었는데 실제로는 $-2$ 가 되었다.이러한 문제점 때문에 부호비트를 통해 음수를 표현하는 것은 잘 쓰이질 않는다.1의 보수one’s complement양수의 모든 비트를 뒤집는 방법이며, 부호비트 표기법과 비슷하게 부호비트와 나머지로 나눈다.1 의 보수라는 문맥에서는 NOT 연산을 통해 보수를 얻는다.그러나 위의 표기법도 부호비트 표기법과 마찬가지로 덧셈 연산이 쉽지 않기 때문에 현대 컴퓨터에서는 거의 쓰이질 않는다.2의 보수two’s complement$+ 1$ 을 했을 때 0 이 되는 비트 패턴을 찾고 $-1$ 이라고 표현을 하는 것이다.4비트 수의 경우 $+1$ 의 경우 $0001$ 인데 $1111$ 을 $0001$ 에 더하면 $0000$ 이 된다.이 때 $1111$ 을 $-1$ 패턴으로 사용한다.2의 보수는 모든 비트에 NOT 연산을 수행하고 거기에 1 을 더하는 것이다.이 때 MSB 를 넘어가는 값은 버린다.예를 들어보면 $0010(2)$ 를 NOT 연산하면 $1101$ 이 되고 이 때 1을 더하면 $1110$ 이 되며 이를 $-2$ 이라고 하면 된다.  2의 보수는 1의 보수와 부호비트 표기법과 다르고 0 을 표기하는 방법이 하나이기 때문에 현대의 컴퓨터에서는 대부분 2의 보수를 많이 사용한다."
  },
  
  {
    "title": "배치리스트 만들기",
    "url": "/posts/make-batch-list/",
    "categories": "Python, Snippet",
    "tags": "python, snippet",
    "date": "2023-03-14 00:00:00 +0900",
    





    
    "snippet": "Summary파일명이나 이미지 등이 들어가있는 리스트와 배치 사이즈를 입력 받아 그 리스트를 배치 단위로 잘라주는 함수이다.Source Codedef make_batch_list(self, file_list: List[], batch_size: int) -&gt; List[]:    result_list = []    for idx in range(0...",
    "content": "Summary파일명이나 이미지 등이 들어가있는 리스트와 배치 사이즈를 입력 받아 그 리스트를 배치 단위로 잘라주는 함수이다.Source Codedef make_batch_list(self, file_list: List[], batch_size: int) -&gt; List[]:    result_list = []    for idx in range(0, len(file_list), batch_size):        if idx + batch_size &lt; len(file_list):            result_list.append(file_list[idx:idx+batch_size])        else:            result_list.append(file_list[idx:])    return result_listExplenationdef make_batch_list(self, file_list: List[], batch_size: int) -&gt; List[]:input data 로 잘라 줄 대상이 될 리스트와 잘라 줄 단위인 배치 사이즈를 지정한다.result_list = []배치 단위로 잘린 결과를 담을 리스트를 선언한다.for idx in range(0, len(file_list), batch_size):배치 사이즈 단위로 반복문을 수행한다.(for in range(a, b, c) 에서 a 는 start, b 는 end, c 는 step 을 뜻한다.)if idx + batch_size &lt; len(file_list):    result_list.append(file_list[idx:idx+batch_size])현재 파일 위치 + 배치 사이즈의 크기가 리스트의 최대 길이를 넘지 않는다면 그 범위만큼 잘라 추가해준다.else:  # == idx + batch_size &gt; len(file_list)    result_list.append(file_list[idx:])반대로 현재 파일 위치 + 배치 사이즈의 크기가 최대 길이를 넘었다면 현재 파일 위치에서 리스트의 끝까지 추가한다.return result_list모든 리스트를 순회해서 배치 단위로 잘라준 리스트를 반환한다.Resulttest_list = [i for i in range(10)]batch_list = make_batch_list(test_list, 3)batch_list2 = make_batch_list(test_list, 4)print(batch_list)print(batch_list2)# 결과# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]# [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9]]"
  },
  
  {
    "title": "컴퓨터 구조 (1)",
    "url": "/posts/computer-structure-1/",
    "categories": "Computer Science",
    "tags": "",
    "date": "2023-03-13 00:00:00 +0900",
    





    
    "snippet": "컴퓨터 내부의 언어 체계  언어란? 기호의 집합으로 인코딩encoding 된 것을 당사자들간 모두 같은 문맥context 로 의사소통하는 것비트bit  binary + digit 의 합성어  0, 1 을 나타내는 이진법 사용  기호는 주관적이므로 켜짐 / 꺼짐, 낮 / 밤 등이 될 수 있다논리연산logical operation  다른 비트들이 표현하는...",
    "content": "컴퓨터 내부의 언어 체계  언어란? 기호의 집합으로 인코딩encoding 된 것을 당사자들간 모두 같은 문맥context 로 의사소통하는 것비트bit  binary + digit 의 합성어  0, 1 을 나타내는 이진법 사용  기호는 주관적이므로 켜짐 / 꺼짐, 낮 / 밤 등이 될 수 있다논리연산logical operation  다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작불리언 대수boolean  비트에 사용할 수 있는 연산 규칙의 집합      일반 대수와 마찬가지로 결합 법칙, 교환 법칙, 분배 법칙 등을 적용 가능    NOT: 논리적 반대를 의미, 참 -&gt; 거짓, 거짓 -&gt; 참으로 연산  AND: 둘 이상의 비트에 작용          연산의 대상이 되는 비트 참 인 경우에만 참        OR: 둘 이상의 비트에 작용          연산의 대상이 되는 비트 중 하나라도 참인 경우에 참        XOR (ExclusiveOR): 둘 이상의 비트에 작용          연산이 되는 대상의 비트 중 하나 이상의 비트가 참일 때 참      연산이 되는 대상의 비트 중 모든 비트가 참인 경우엔 거짓        XOR 연산은 (a OR b) AND (NOT(a AND b)) 로 만들 수 있다드모르간의 법칙  불리언 대수에 적용할 수 있는 법칙            a      b      a AND b      NOT a      NOT b      NOT a OR NOT b      NOT (NOT a OR NOT b)                  F      F      F      T      T      T      F              F      T      F      T      F      T      F              T      F      F      F      T      T      F              T      T      T      F      F      F      T      위 표에서 봤을 때 AND 연산 또한 NOT 과 OR 을 이용해 만들 수 있다드모르간 법칙은 입력받은 비트의 연산을 최소화하기 위해서 사용될 수 있다"
  },
  
  {
    "title": "우분투 환경 세팅 (3)",
    "url": "/posts/ubuntu-env-setting-3/",
    "categories": "Ubuntu, Settings",
    "tags": "ubuntu, settings, git, vscode",
    "date": "2023-03-12 00:00:00 +0900",
    





    
    "snippet": "설치 환경  Geforece 3090  Ubuntu 20.04 LTSGit 설치sudo apt-get install git 명령어로 설치 가능하다git --version 혹은 git -V 으로 설치 여부를 확인한 뒤 git config 명령어로 설정을 완료한다git config --user.name {user_name}git config --user....",
    "content": "설치 환경  Geforece 3090  Ubuntu 20.04 LTSGit 설치sudo apt-get install git 명령어로 설치 가능하다git --version 혹은 git -V 으로 설치 여부를 확인한 뒤 git config 명령어로 설정을 완료한다git config --user.name {user_name}git config --user.email {user_email}git config --list마지막 줄 명령어로 입력한 config 가 제대로 적용 되었는지 확인한다VScode 설치VScode official site 으로 접속해 자신의 os 에 맞는 실행 파일 .deb 을 받는다터미널에 다운로드 경로로 이동해 sudo apt install ./{file_name} 를 입력하여 설치를 진행한다터미널을 재실행 한 뒤 code 를 입력하면 vscode 가 켜진다 (혹은 그냥 vscode 를 검색해서 실행시킬 수 있다)"
  },
  
  {
    "title": "우분투 환경 세팅 (2)",
    "url": "/posts/ubuntu-env-setting-2/",
    "categories": "Ubuntu, Settings",
    "tags": "ubuntu, settings, anaconda",
    "date": "2023-03-11 00:00:00 +0900",
    





    
    "snippet": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSAnaconda 설치Anaconda official site 를 통해 자신의 os 에 맞는 버전을 선택해 다운로드 받는다파일이 다운로드 된 경로로 이동해 설치를 진행하기 전 sha256sum {file_name} 명령어를 통해 데이터 무결성을 검사한다해당 명령어를 입력하면 해시값이 나오...",
    "content": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSAnaconda 설치Anaconda official site 를 통해 자신의 os 에 맞는 버전을 선택해 다운로드 받는다파일이 다운로드 된 경로로 이동해 설치를 진행하기 전 sha256sum {file_name} 명령어를 통해 데이터 무결성을 검사한다해당 명령어를 입력하면 해시값이 나오는데 이를 복사한뒤 Hashes for all files 접속해 복사한 해시값이 있는지 확인한다해시값이 있는지 확인이 되면 bash {file_name} 혹은 ./{file_name} 를 통해 .sh 파일을 실행해 설치를 진행한다파일을 실행하면 Terms and conditions 등이 지나간 뒤 설치 경로를 지정해주고 (enter 를 누르면 default, 다른 경로 지정은 직접 입력) &lt;/br&gt;설치를 좀 더 진행하면 [yes|no] 를 선택하라는 문구가 나오는데 yes 를 선택한다(no 를 선택하면 아나콘다 환경에서 쉘 스크립트를 수정할 수 없다)Anaconda Prompt 사용 설정아나콘다를 설치하더라도 바로 conda 명령어 (e.g. conda create, conda env list, conda instal, …) 가 먹히지 않는다ananconda prompt 를 사용하기 위해선 vim ~/.bashrc 를 통해 맨 아래줄에 해당 명령어를 추가해준다  export PATH=~/ananconda3/bin:~/ananconda3/condabin:$PATHsource ~/.bashrc 입력 후 터미널을 껐다 키면 앞에 (base) 가 붙는다Anaconda prompt 자동 실행 옵션 해제conda config --set auto_activate_base False 를 터미널에 입력 후 껐다키면 (base) 가 사라진다(터미널 실행 시 자동으로 Anaconda prompt 가 실행 되는 것을 방지)anaconda prompt 를 실행하기 위해선 conda acitvate 를 입력하면 앞에 켜지고 conda deactivate 를 입력하면 꺼진다"
  },
  
  {
    "title": "우분투 환경 세팅 (1)",
    "url": "/posts/ubuntu-env-setting-1/",
    "categories": "Ubuntu, Settings",
    "tags": "ubuntu, settings, cuda, cudnn",
    "date": "2023-03-09 00:00:00 +0900",
    





    
    "snippet": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSpre-setting그래픽 드라이버를 설치하기 전 필요한 패키지들을 먼저 설치해준다sudo apt-get update &amp;&amp; sudo apt-get upgrade -ysudo apt-get install openssh-serversudo apt-get install net-...",
    "content": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSpre-setting그래픽 드라이버를 설치하기 전 필요한 패키지들을 먼저 설치해준다sudo apt-get update &amp;&amp; sudo apt-get upgrade -ysudo apt-get install openssh-serversudo apt-get install net-toolssudo apt-get install build-essentialsudo apt-get install manpages-devgcc -V 으로 gcc 컴파일러 설치 확인 (이후에 CUDA 설치할 때 필요)그래픽 드라이버 확인 및 설치터미널에 ubuntu-drivers devices 를 입력하면 현재 그래픽카드와 os 에 맞는 그래픽 드라이버들이 출력 된다sudo apt-get install nvidia-driver-autoinstall 는 권장설치 sudo apt-get install nvidia-driver-{version} 는 본인이 원하는 버전을 수동으로 설치한다나는 515 버전을 설치했다 sudo apt-get install nvidia-driver-515CUDA 설치cuda-toolkit-archive 링크로 접속해 원하는 버전의 자신의 os 에 맞는 CUDA 를 받는다나는 Linux -&gt; x86_64 -&gt; Ubuntu -&gt; 20.04 -&gt; runfile(local) 을 통해 파일을 받았다.deb 파일로도 받을 수 있고 network 를 통해서 설치할 수 있다설치 방법은 nvidia 홈페이지에 나와있는 대로 실행하면 된다CUDA 11.7, 그래픽드라이버 515 기준 wget https://developer.download.nvidia.com/compute/cuda/11.7.0/local_installers/cuda_11.7.0_515.43.04_linux.runcd ~/Downloadssudo sh cuda_11.7.0_515.43.04_linux.run참고로 파일을 실행한 다음 설치 할 파일들을 선택할 수 있는 창이 뜨는데, 이 때 그래픽 드라이버는 위에서 이미 설치를 했기 때문에 선택을 해제하고 설치를 마저 진행하면 된다cuDNN 설치cudnn-archive 링크로 접속해 본인의 상황에 맞는 cuDNN 을 다운로드 받는다nvidia 계정을 요구하므로 가입하고 진행하면 된다다운로드가 완료 되면 파일이 있는 위치로 가 압축파일을 해제한다tar.gz 파일은 tar xvzf {file_name} 명령어로tar 파일은 tar xvf {file_name} 명령어로 해제한다압축을 해제하면 해당 폴더 안으로 들어간뒤 폴더 내의 내용물들을 전부 CUDA 가 설치 된 위치에 복사하면 된다같은 이름의 파일이 있다고 할텐데 replace 시켜주면 된다sudo cp ./{cuDNN dir}/include/* /usr/local/{cuda dir}/includesudo cp ./{cuDNN dir}/lib64/* /usr/local/{cuda dir}/lib64sudo chmod a+r /usr/local/{cuda dir}/lib64/libcudnn*환경변수 설정위에서 모든 파일의 설치 및 복사가 완료 되었으면 다음은 컴퓨터의 어떤 경로에서든지 CUDA 와 cuDNN 을 참조할 수 있도록 환경 변수를 설정한다vi 이나 vim 편집기로 파일을 열어주면 되는데, 없다면 sudo apt-get install vim 등을 이용하여 먼저 설치해준다vim ~/.bashrc 로 파일을 열어준 뒤export PATH=/usr/local/{cuda-version}/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda/lib64:${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}를 파일 제일 아래에 추가해 준다(vim 에서 문서를 처음 편집하려고 할 때 아무것도 입력이 안 되는데 이는 vim 의 명령어 모드이기 때문이다. i, o, a 등의 명령어로 입력 모드로 변경한 뒤 입력해주고 esc 를 눌러 다시 명령어 모드로 바꾸고 :wq 를 입력하여 최종적으로 입력 내용을 저장한다)source ~/.bashrc 를 입력하여 해당 내용이 적용 될 수 있도록 한다설치 확인nvidia-smi 와 nvcc -V 혹은 nvcc --version 을 입력하여 그래픽 드라이버와 CUDA 가 잘 설치 되었는지를 확인하면 된다참고로 nvidia-smi 에서 출력 되는 드라이버는 현재 설치 된 드라이버가 아닌 최신 드라이버이므로 혼동하면 안 된다"
  }
  
]

