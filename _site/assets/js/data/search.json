[
  
  {
    "title": "Opencv Affine",
    "url": "/posts/opencv-affine/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2024-01-15 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.영상의 기하학적인 변환  영상을 구성하는 픽셀의 배치 구조를 변경함으로써 전체 영상의 모양을 바꾸는 작업이다.  픽셀의 밝기, 명암비, 필터링 조작과 달리 픽셀의 값은 유지한채 위치만 변경시킨다.  \\[\\begin{cas...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.영상의 기하학적인 변환  영상을 구성하는 픽셀의 배치 구조를 변경함으로써 전체 영상의 모양을 바꾸는 작업이다.  픽셀의 밝기, 명암비, 필터링 조작과 달리 픽셀의 값은 유지한채 위치만 변경시킨다.  \\[\\begin{cases}  x' = f_1(x, y) \\\\  y' = f_2(x, y) \\\\\\end{cases}\\]  어파인 변환 (Affine Transform)  영상을 평행 이동시키거나 회전, 크기 변환 등을 통해 만들 수 있는 변환을 통칭한다.  직선간의 길이 비율과 평행관계가 그대로 유지 되며 직선은 그대로 직선을 나타낸다.  \\[\\begin{cases}  x' = f_1(x, y) = ax + by + c \\\\  y' = f_2(x, y) = dx + ey + f \\\\\\end{cases}\\]    어파인 변환 행렬을 통해 어파인 변환을 수행한다.  cv::Mat cv::warpAffine(src, dst, M, dsize, flags, borderMode, borderValue);로 변환을 수행한다.어파인 변환 행렬  위의 식을 행렬 변환 시킨 행렬.  \\(\\begin{pmatrix}  (a &amp; b &amp; c) \\\\  (d &amp; e &amp; f) \\\\\\end{pmatrix}\\)의 2, 3 모양의 행렬로 변환 가능하다.  어파인 변환 행렬을 구하기 위해선 두 행렬 간의 세 점의 이동 관계를 알아야한다.  cv::Mat cv::getAffineTransform(src[], dst[]);  cv::Mat cv::getAffineTransform(src, dst);          위의 두 함수 중 하나를 사용하여 변환 행렬을 구한다.      src[]들은 cv::Point2f 형태      src들은 cv::Mat의 행태이다.      #include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;void affine_transform();int main(void){    affine_transform();    return 0;}void affine_transform(){    cv::Mat src = cv::imread(\"path/to/src\", cv::IMREAD_GRAYSCALE);    cv::Point2f srcPts[3], dstPts[3];  // 3 점을 갖는 cv::Point2f 행렬 선언    srcPts[0] = (0, 0);    srcPts[1] = (src.cols - 1, 0);    srcPts[2] = (src.cols - 1, src.rows - 1);    dstPts[0] = (50, 50);    dstPts[1] = (src.cols - 100, 100);    dstPts[2] = (src.cols - 50, src.rows - 50);    cv::Mat M = cv::getAffineTransform(srcPts, dstPts);  // affine transform matrix 를 얻는다.    cv::Mat dst;    cv::warpAffine(src, dst, M, cv::Size());  // affine 변환    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);    cv::waitKey(0);    cv::destroyAllWindows();}cv::transform  행렬 src의 점이 행렬 dst의 어느 위치로 이동했는지 알려주는 함수이다.  cv::Mat cv::transform(src, dst, M);          src: std::vector&lt;cv::Point2f&gt;의 형태      dst: std::vector&lt;cv::Point2f&gt;의 형태      M: cv::Mat의 형태의 어파인 변환 행렬이다.      ...    std::vector&lt;cv::Point2f&gt; s = {srcPts[0], srcPts[1], srcPts[2]};    std::vector&lt;cv::Point2f&gt; d;    cv::transform(s, d, M);..."
  },
  
  {
    "title": "OpenCV 잡음 제거 필터링",
    "url": "/posts/opencv-denoise/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2024-01-04 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.잡음 (Noise)  원본 신호에 추가 된 원치 않은 신호를 의미한다.  영상의 경우 영상을 획득하는 과정 중에 많이 발생한다.          광학적 신호를 전기적 신호로 바꾸는 센서에서 주로 발생한다.        $...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.잡음 (Noise)  원본 신호에 추가 된 원치 않은 신호를 의미한다.  영상의 경우 영상을 획득하는 과정 중에 많이 발생한다.          광학적 신호를 전기적 신호로 바꾸는 센서에서 주로 발생한다.        $f(x, y) = s(x, y) + n(x, y)$          $f(x, y)$는 출력영상.      $s(x, y)$는 센서에서 들어온 입력 영상.      $n(x, y)$는 노이즈.      잡음 모델  잡음이 생성 되는 방식을 의미한다.  다양한 모델이 존재하며 가장 대표적인 것은 가우시안 잡음 모델이다.          평균이 $0$인 가우시안 분포를 따르는 잡음을 의미한다.      평균이 $0$이고 표준편차가 $\\sigma$인 가우시안 분포는 $x$값이 $-\\sigma\\leqq{x}\\leqq{\\sigma}$ 구간에서 전체 데이터의 $67\\%$가 존재하며, $-2\\sigma\\leqq{x}\\leqq{2\\sigma}$ 구간에서 전체 데이터의 $95\\%$가 존재, $-3\\sigma\\leqq{x}\\leqq{3\\sigma}$ 구간에서 전체 데이터의 $99.7\\%$가 존재한다.        표준편차가 작은 가우시안 모델일수록 잡음에 의한 픽셀값의 변화가 적어진다.cv::randn(dst, mean, stddev)  dst 행렬을 가우시안 분포를 따르는 난수로 채운다.  dst 행렬은 미리 적절한 타입으로 정의 되어있어야하며, 생성 된 난수는 dst 행렬의 자료형에 맞게끔 포화연산 된다.  평균이 $0$인 가우시안 잡음을 생성 할 경우 양수와 음수가 섞여있는 난수가 발생 되므로 CV_32S, CV_32F처럼 부호가 있는 자료형을 선택한다.#include \"opencv2/opencv.hpp\"void noise_gaussian();int main(void){    noise_gaussian();    return 0;}void noise_gaussian(){    cv::Mat src = cv::imread(\"path/to/src\", cv::IMREAD_GRAYSCALE);    std::vector&lt;cv::Mat&gt; noised({src});    for (int stddev = 10; stddev &lt;= 30; stddev+=10)    {         cv::Mat noise(src.size(), CV_32SC1);  // 노이즈 생성         cv::rand(noise, 0, stddev);         cv::Mat dst;         cv::add(src, noise, cv::Mat(), CV_8U);  // 노이즈 추가        noised.push_back(dst);    }    cv::Mat images;    cv::hconcat(noised, images);    cv::imshow(\"debug\", images);    cv::waitKey();    cv::destroyAllWindows();}양방향 필터 (Biateral filter)  에지 정보는 그대로 유지하면서 잡음만 제거하는 에지 보전 잡음 제거 필터 (edge-preserving noise removal filter).  대부분의 영상에는 가우시안 잡음이 포함 되어있으므로 가우시안 필터를 통해 노이즈를 제거한다.          가우시안 필터를 이용한 노이즈 제거는 가우시안 잡음을 효과적으로 제거하지만 그만큼 에지 성분도 감소하게 되면서 영상이 전체적으로 흐릿해진다.      양방향 필터를 이용하게 되면 에지 성분은 유지하되 잡음은 제거할 수 있다.        $G_p = \\frac{1}{W_p}\\sum\\limits_{q\\in{S}}G_{\\sigma_s}(\\rVert p - q \\lVert)G_{\\sigma_r}(\\mid \\int_p - \\int_q \\mid)$          $\\int$는 입력, $G$는 출력이다.      $p, q$는 각각 픽셀의 좌표이다.      $\\int_p, \\int_q$는 $p$점과 $q$점간의 입력 영상 픽셀값, $G_p$는 p$점에서의 출력영상 픽셀값이다.      $S$는 필터의 크기, $W_p$는 양방향 필터 마스크 합이 1이 되도록하는 정규화 상수이다.      해당 식은 두 개의 가우시안 함수의 곱으로 이루어져있다.      $G_{\\sigma_s}(\\rVert p - q \\lVert)$ 는 두 점 사이의 거리에 대한 가우시안 함수      $G_{\\sigma_r}(\\mid \\int_p - \\int_q \\mid)$ 는 두 점의 픽셀값 차이에 의한 가우시안 함수                  두 점의 픽셀 밝기의 차이가 적은 평탄한 지역에선 큰 가중치를 갖고 에지를 사이에 두면 $0$에 가까운 작은 값을 갖게 된다.                      픽셀값의 차이에 의존적이기 때문에 모든 픽셀에 대해 서로 다른 형태를 갖게 된다.  모든 픽셀의 밝기 차이에 의한 고유의 마스크 필터 행렬을 만들어 마스크 연산을 수행해야한다.          일반적인 가우시안 블러링보다 훨씬 많은 연산량을 갖게 된다.        cv::biateralFilter(src, dst, d, sigmaColor, sigmaSpace, borderType);          d: 필터링에 사용할 이웃 픽셀간의 거리 (양수가 아닌 값을 지정하면 sigmaSpace에서 자동으로 계산한다.)      sigmaColor: 픽셀 값 차이에 따라 차이가 작으면 차이가 큰 주변 픽셀과는 블러링이 되지 않으며 차이가 크면 주변 픽셀과도 블러링 연산을 수행한다.      sigmaSpace: 일반적인 표준편차 값이다.      #include \"opencv2/opencv.hpp\"void filter_bialteral();int main(void){    filter_bialteral();    return 0;}void filter_bialteral(){    cv::Mat src = cv::imread(\"path/to/src\", cv::IMREAD_GRAYSCALE);    cv::Mat noise(src.size(), CV_32SC1);  // 노이즈 생성    cv::randn(noise, 0, 5);    cv::Mat dst1;    cv::GaussianBlur(src, dst1, cv::Size(), 5);  // 표준편차가 5인 가우시안 블러 연산 처리    cv::Mat dst2;    cv::bialteralFilter(src, dst2, -1, 10, 5);  // 색 표준편차가 10 이고 거리 표준편차가 5 인 양방향 필터링 연산 수행    std::vector&lt;cv::Mat&gt; blurred({src, dst1, dst2});        cv::Mat images;    cv::hconcat(blurred, images);        cv::imshow(\"debug\", images);    cv::waitKey();    cv::destroyAllWindows();}미디언 필터 (Median filter)  입력 영상에서 자기 자신의 픽셀과 주변 픽셀 값 중에서 중간값을 선택하여 결과 영상 픽셀값으로 설정하는 필터링이다.  마스크 행렬과 입력 영상의 픽셀값을 서로 곱한 후 모두 더하는 등의 연산을 수행하지 않는다.  주변 픽셀들의 중간값을 선택하기 위해 내부에서 픽셀을 정렬한다.          e.g.) $((48, 60, 72), (52, 102, 88), (69, 84, 92))$ 형태인 3x3 형태의 행렬의 중간값인 $72$로 선택해 필터링 연산을 수행한다.        잡은 픽셀값이 주변 픽셀값과 차이가 큰 경우에 더욱 효과적이다.          Salt &amp; Pepper 잡음 등에 효과적이다.                  픽셀의 값이 $0$ 또는 $255$으로 변경 되는 형태의 잡음.                      cv::medianBlur(src, dst, ksize);          ksize: 필터 크기, $3$과 같거나 큰 홀수를 지정해야한다.      내부적으로 BORDER_REPLICATE를 수행한다.      #include \"opencv2/opencv.hpp\"void filter_median();int main(void){    filter_median();    return 0;}void filter_median(){    cv::Mat src = cv::imread(\"path/to/src\", cv::IMREAD_GRAYSCALE);    // salt &amp; pepper noise    cv::Mat noise = src.clone();    int num = (int)(noise.total() * 0.1);    for (int i = 0; i &lt; num; i++)    {        int x = rand() % noise.cols;        int y = rand() % noise.rows;        noise.at&lt;uchar&gt;(y, x) = (i % 2) * 255;    }    cv::Mat dst;    cv::medianBlur(noise, dst, 3);  // 필터 크기를 3으로 하는 메디안 필터 연산 수행    std::vector&lt;cv::Mat&gt; blurred({src, dst});    cv::Mat images;    cv::hconcat(bluured, images);    cv::imshow(\"debug\", images);    cv::waitKey();    cv::destroyAllWindows();}"
  },
  
  {
    "title": "OpenCV 샤프닝",
    "url": "/posts/opencv-sharpening/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2024-01-03 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.샤프닝 (Sharpening)  블러링과 반대로 윤곽이 뚜렷하고 선명한 느낌이 나도록한다.  영상의 에지 근방에서 픽셀값의 명암비가 커지도록 수정해야 선명한 영상이 나온다.언샤프 마스크 필터 (Unsharp mask fi...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.샤프닝 (Sharpening)  블러링과 반대로 윤곽이 뚜렷하고 선명한 느낌이 나도록한다.  영상의 에지 근방에서 픽셀값의 명암비가 커지도록 수정해야 선명한 영상이 나온다.언샤프 마스크 필터 (Unsharp mask filter)  샤프닝은 우선 입력 영상을 블러링 처리를 한 뒤 최종적으로 샤프닝 처리를 한다.  입력 영상을 블러처리한 뒤 함수값의 증감도를 그래프화 시킨다.  함수값이 증가하는 부분에선 음수, 증가가 멈추는 부분에선 양수로 변환이 되는데, 이 그래프를 기존의 입력 영상에 대해 빼기 연산을 실시한다.  $h(x, y) = f(x, y) + \\alpha * g(x, y)$          $h(x, y)$는 출력 영상      $f(x, y)$는 입력 영상      $g(x, y)$는 블러링 처리 후 픽셀의 변화도를 연산한 영상이다.      $\\alpha$는 샤프닝의 가중치를 의미하며 $1$보다 크면 더욱 날카롭게 $1$보다 작으면 덜 날카롭게 영상을 출력한다.        OpenCV에서 언샤프 마스크 필터 함수를 따로 제공하지는 않으므로 직접 구현해야한다.#include \"opencv2/opencv.hpp\"void unsharpMask();int main(void){    unsharpMask();    return 0;}void unsharpMask(){    cv::Mat src = cv::imread(\"./lenna.bmp\", cv::IMREAD_GRAYSCALE);    std::vector&lt;cv::Mat&gt; images({src});    for (int sigma = 1; sigma &lt;= 5; sigma++)    {        cv::Mat blurred;        cv::GaussianBlur(src, blurred, cv::Size(), (double)sigma);        float alpha = 1.f;        cv::Mat dst = src + alpha * (src - blurred);        images.push_back(dst);    }    cv::Mat result;    cv::hconcat(images, result);    cv::imshow(\"debug\", result);    cv::waitKey();    cv::destroyAllWindows();}"
  },
  
  {
    "title": "OpenCV 블러링",
    "url": "/posts/1opencv-blurring/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2024-01-03 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.블러링 (Blurring)  영상을 부드럽게 만드는 기법. 스무딩 (smoothing) 이라고도 한다.  인접한 픽셀간 픽셀값의 변화가 크지 않은 경우 부드러운 느낌을 받을수 있다.  거친 입력 영상을 부드럽게 하거나 노...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.블러링 (Blurring)  영상을 부드럽게 만드는 기법. 스무딩 (smoothing) 이라고도 한다.  인접한 픽셀간 픽셀값의 변화가 크지 않은 경우 부드러운 느낌을 받을수 있다.  거친 입력 영상을 부드럽게 하거나 노이즈를 제거하는 전처리 과정으로 사용할 수 있다.  OpenCV 에서는 cv::blur(평균값 필터) 와 cv::GaussianBlur(가우시안 필터) 함수를 제공한다.평균값 필터 (Mean filter)  블러링 필터 중에서 간단하고 구현하기 쉬운 필터이다.  입력 영상에서 특정 픽셀과 주변 픽셀들의 산술 평균을 결과 영상 픽셀값으로 설정한다.  급격한 변화가 줄어들어 에지가 무뎌지고 잡음의 영향이 크게 사라지는 효과가 있다.          너무 과도하게 사용하면 경계가 흐릿해지고 사물의 구분이 어려워지는 단점이 존재한다.        마스크 크기가 커지면 커질수록 영상은 더 부드러워지지만 그만큼 연산량이 크게 증가하게 된다.  보통 정사각행렬을 사용한다.#include \"opencv2/opencv.hpp\"void blurMean();int main(void){    return 0;}void blurMean(){    cv::Mat src = cv::imreaD(\"path/to/src\", cv::IMREAD_GRAYSCALE);    std::vector&lt;cv::Mat&gt; blurred({src});    for (int ksize = 3; ksize &lt;= 5; ksize+=2)    {        cv::Mat dst;        cv::blur(src, dst, cv::Size(ksize, ksize));        blurred.push_back(dst);    }    cv::Mat images;    cv::hconcat(blurred, images);    cv::imshow(\"debug\", images);    cv::waitKey();    cv::destroyAllWindows();}가우시안 필터  평균값 필터보다 자연스러운 블러링 기법이다.  가우시안 분포 함수를 근사하여 생성한 필터를 마스크를 사용한다.          가우시안 분포는 평균과 표준 편차에 따라 분포모양이 결정 되지만 영상의 경우 평균이 $0$인 가우시안 분포 함수를 사용한다.      또한 영상은 2차원 행렬이므로 평균이 $(0, 0)$이므로 $x$ 축과 $y$ 축 방향의 표준편차가 각각 $\\sigma_{x}$, $\\sigma_{y}$ 인 2차원 가우시안 분포 함수를 사용한다.        $G_{\\sigma_{x}\\sigma_{y}} = \\frac{1 * e^{\\frac{-x^2}{2\\sigma_{x}^{2}} + \\frac{y^2}{2\\sigma_{}y^{2}}}}{2\\pi\\sigma_{x}\\sigma_{y}}$          헤딩 식의 경우 한 픽셀 당 $81$번의 연산이 이루어지기 때문에 연산량이 굉장히 많다.      $G_{\\sigma_{x}}, G_{\\sigma_{y}}$ 의 형태로 나누게 되면 $18$번의 연산만 수행하면 되므로 훨씬 경제적이다.                  $G_{x}$ 연산 후 $(G_{x})^{T}$ 으로 연산한다.                      평균이 $0$이고 표준편차가 $\\sigma$인 경우에 $x$의 값은 대부분 $-4\\sigma$ ~ $4\\sigma$에 분포하기 때문에 크기는 보통 $8\\sigma + 1$로 결정한다.  cv::GaussianBlur(cv::Mat src, cv::Mat dst, cv::Size ksize, double sigmaX, double sigmaY, int borderType)          ksize: cv::Size()로 주어 자동으로 마스크의 크기를 결정해주는 편이 좋다.      sigmaY: $0$ 혹은 지정하지 않으면 y축으로 sigmaX 값과 동일한 값을 가지는 표준 편차를 사용한다.      #include \"opencv2/opencv.hpp\"void blurGaussian();int main(void){    blurGaussian();    return 0;}void blurGaussian(){    cv::Mat src = cv::imread(\"path/to/src\", cv::IMREAD_GRAYSCALE);    std::vecotr&lt;cv::Mat&gt; blurred({src});    for (int sigma = 1; sigma &lt;= 5; sigma++)    {        cv::Mat dst;        cv::GaussianBlur(src, dst, cv::Size(), (double)sigma);        blurred.push_back(dst);    }    cv::Mat images;    cv::hconcat(blurred, images);    cv::imshow(\"debug\", blurred);    cv::waitKey();    cv::destroyAllWindows();}"
  },
  
  {
    "title": "OpenCV 필터링",
    "url": "/posts/0opencv-filtering/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2024-01-03 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.필터링 (Filtering)  영상에서 원하는 정보만을 걸러내는 연산을 수행한다.  영상을 부드럽게 처리하거나, 반대로 선명하게 만들거나, 노이즈를 제거하는 등의 연산을 한다.  마스크 행렬을 통해 연산을 실시한다.  c...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.필터링 (Filtering)  영상에서 원하는 정보만을 걸러내는 연산을 수행한다.  영상을 부드럽게 처리하거나, 반대로 선명하게 만들거나, 노이즈를 제거하는 등의 연산을 한다.  마스크 행렬을 통해 연산을 실시한다.  cv::filter2D라는 기본적인 필터링 함수를 제공한다.          cv::filter2D(cv::Mat src, cv::Mat dst, int ddpeth, cv::Mat Kernel, cv::Point anchor = cv::Point(-1, -1), borderType = BORDER_DEFAULT      ddepth: 출력 영상의 깊이, -1 을 지정한 경우 입력 영상과 동일한 깊이로 반환하나.                  입력 영상 src.type()에 따른 ddepth 값.                          CV_8U = -1, CV_16S, CV_32F, CV_64F              CV_16S = -1, CV_32F, CV_64F              CV_32F = -1, CV_64F              CV_64F = -1                                          kernel: 필터링 커널, 1채널 실수형 행렬.      anchor: 고정점 좌표. cv::Point(-1, -1)인 경우 커널의 중심을 고정점으로 사용한다.      delta: 필터링 후 추가적으로 더할 값.        $dst(x, y) = \\sum\\limits_{i}\\sum\\limits_{j}kernel(i, j) * src(x + i - anchor.x, y + j - anchor.y) + delta$마스크 (Mask)  작은 크기의 행렬이다.  필터링의 성격을 정의하는 행렬이며 커널 (kernel), 윈도우 (window) 라고 부르며 마스크 자체를 필터라고 부르기도 한다.  마스크 행렬의 원소는 주로 실수로 구성 되며, 직사각형이나 정사각형 등 형태나 크기가 다양하다.  마스크 행렬의 원소 총합은 1이 되도록 구성하는 것이 일반적이다.          입력 영상과 출력 영상의 밝기가 동일해지기 때문이다.      총합이 1보다 크면 출력 영상의 평균 밝기가 증가한다. (밝아진다.)      총합이 1보다 작으면 출력 영상의 평균 밝기가 감소한다. (어두워진다.)      고정점  현재 필터링을 수행하는 마스크의 기준 픽셀의 위치를 나타내며 주로 마스크의 정중앙을 고정점으로 사용한다.수식  \\[G(x, y) = m(0, 0)f(x - 1, y -1) + m(1, 0)f(x, y -1) + m(2, 0)f(x + 1, y - 1)  \\\\ + m(0, 1)f(x - 1, y) + m(1, 1)f(x, y) + m(2, 1)f(x + 1, y)  \\\\ + m(0, 2)f(x - 1, y + 1) + m(1, 2)f(x, y + 1) + m(2, 2)f(x + 1, y + 1)\\]          (x, y) 좌표에서 마스크 연산을 통해 G(x, y)를 구했다면 마스크를 한 픽셀 옆으로 움직여 (x + 1, y) 에서 다시 마스크 연산을 수정하여 G(x + 1, y)에 저장한다.      해당 연산을 영상 전체에 대해 수행하면 필터링이 완료 된다.      패딩 (Padding, border)  영상의 가장자리 부근에서는 필터링의 연산이 제대로 되지 않으므로 마스크 행렬의 크기만큼의 값을 가지는 가상의 픽셀을 만들어낸다.  패딩의 방법으로는 constant, replicate, reflect, reflect_101, reflect101, default등이 존재한다.          constant: 지정한 상수값으로 패딩한다. 000|abcdefg|000      replicate: 가장 자리 픽셀 (경계선 픽셀) 의 값으로 패딩한다. aaa|abcdefg|ggg      reflect: 가장자리 픽셀로부터의 패딩 크기까지의 모양으로 패딩한다. cba|abcdefg|gfe      reflect_101: 가장자리 픽셀을 기준으로 패딩 크기까지의 모양으로 패딩한다. dcb|abcdefg|fed      reflect101, default: reflect_101과 동일하다.      엠보싱 필터 (Embossing filter)  픽셀값 변화가 적은 평탄한 영역은 회색으로, 픽셀값의 변화가 큰 경계면은 더 밝거나 어둡게한다.  대각선 방향으로 $+1$ 또는 $-1$ 값이 지정 되어있는 3 x 3 행렬          \\[\\begin{pmatrix}  -1 &amp; -1 &amp; 0  \\\\  -1 &amp; 0 &amp; 1  \\\\  0 &amp; 1 &amp; 1  \\\\  \\end{pmatrix}\\]              해당 마스크를 통해 대각선 방향으로 변화가 크게 되면 픽셀의 결과가 $0$보다 현저히 낮거나 크게 된다.          반대로 변화가 적은 부분은 $0$에 가깝게 수렴 되며 $0$보다 작은 부분은 포화연산이 되기 때문에 전반적으로 어두운 영상이 되며 입체감이 줄어들게 된다.      최종 결과물의 각 픽셀에 $128$을 더해 입체감을 준다.      #include \"opencv2/opencv.hpp\"void filterEmbossing();int main(void){  filterEmbossing();  return 0;}void filterEmbossing(){  cv::Mat src = cv::imread(\"path/to/src\", cv::IMREAD_GRAYSCALE);  float data[] = {-1, -1, 0, -1, 0, 1, 0, 1, 1};  cv::Mat mask(3, 3, CV_32FC1, data);  cv::Mat dst;  cv::filter2D(src, dst, -1, mask, cv::Point(-1, -1), 128);  cv::imshow(\"src\", src);  cv::imshow(\"dst\", dst);  cv::waitKey();  cv::destoryAllWindows();}"
  },
  
  {
    "title": "OpenCV 논리연산",
    "url": "/posts/opencv-logical/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2024-01-02 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.논리 연산  픽셀값을 이진수로 표현하여 비트 단위의 논리 연산을 수행한다.  논리곱 (AND), 논리합 (OR), 배타적 논리합 (XOR), 부정 (NOT) 을 지원한다.  AND, OR, XOR은 두 입력 영상의 각 픽...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.논리 연산  픽셀값을 이진수로 표현하여 비트 단위의 논리 연산을 수행한다.  논리곱 (AND), 논리합 (OR), 배타적 논리합 (XOR), 부정 (NOT) 을 지원한다.  AND, OR, XOR은 두 입력 영상의 각 픽셀에 대한 연산을 실시하지만 NOT은 하나의 입력 영상의 전체 픽셀을 일괄적으로 연산한다.  연산자 오버로딩을 지원한다.          AND = &amp;      OR = |      XOR = ^      NOT = ~      #include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src1 = cv::imread(\"path/to/src1\", cv::IMREAD_GRAYSCALE);    cv::Mat src2 = cv::imread(\"path/to/src2\", cv::IMREAD_GRAYSCALE);    cv::Mat dst1, dst2, dst3, dst4;    cv::bitwise_and(src1, src2, dst1);    cv::bitwise_or(src1, src2, dst2);    cv::bitwise_xor(src1, src2, dst3);    cv::bitwise_not(src1, dst4);    cv::Mat images;    cv::hconcat(std::vector&lt;cv::Mat&gt;({dst1, dst2, dst3, dst4}), images);    cv::imshow(\"debug\", images);    cv::waitKey();    cv::destroyAllWindows();    return 0;}"
  },
  
  {
    "title": "OpenCV 산술 연산",
    "url": "/posts/opencv-arithmetic/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book reivew",
    "date": "2024-01-02 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.산술 연산  영상 및 이미지는 2차원 행렬로 볼 수 있으므로 행렬의 산술 연산이 가능하다.  덧셈 및 뺄셈 연산으로 영상을 합성하여 새로운 영상으로 나타낼 수 있다.          곱셈과 나눗셈 연산은 잘 하지 않는다....",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.산술 연산  영상 및 이미지는 2차원 행렬로 볼 수 있으므로 행렬의 산술 연산이 가능하다.  덧셈 및 뺄셈 연산으로 영상을 합성하여 새로운 영상으로 나타낼 수 있다.          곱셈과 나눗셈 연산은 잘 하지 않는다.      add  덧셈 연산.  $dst(x, \\;y) = saturate(src1(x \\;y) \\;+ \\;src2(x, \\;y))$  cv::add(cv::Mat src1, cv::Mat src2, cv::Mat dst, int dtype=-1);  src1와 src2의 데이터 타입이 동일하다면 행렬 연산을 실시한다.  두 입력 영상의 데이터 타입이 다른 경우 한쪽 행렬의 전체 픽셀에 대해 스칼라 덧셈을 실시한다.  + 연산자 오버로딩을 통해 연산이 가능하다.#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src1 = cv::imread(\"path/to/src1\", cv::IMREAD_GRAYSCALE);    cv::Mat src2 = cv::imread(\"path/to/src2\", cv::IMREAD_GRAYSCALE);    cv::Mat dst;    cv::add(src1, src2, dst);    cv::imshow(\"debug\", dst);    cv::waitKey();    cv::destroyAllWindows();    return 0;}addWeighted  두 행렬의 덧셈 연산 시 가중치를 부여한다.  $dst(x, \\;y) = saturate(\\alpha * src1(x, \\;y) + \\beta * src2(x, \\;y))$  cv::addWeighted(cv::Mat src1, double alpha, cv::Mat src2, double beta, int gamma, cv::Mat dst, int dtype=-1);          $\\gamma$는 가중치 결과에 추가로 더할 값이다.        $\\alpha$와 $\\beta$는 각 입력 영상의 가중치를 의미하는 실수이다.          $\\alpha + \\beta = 1$이 보편적이다.      $\\alpha + \\beta &gt; 1$인 경우 두 영상의 평균 밝기보다 높은 밝기의 영상이 출력 된다.      $\\alpha + \\beta &lt; 1$인 경우 두 영상의 평균 밝기보다 낮은 밝기의 영상이 출력 된다.      #include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src1 = cv::imread(\"path/to/src1\", cv::IMREAD_GRAYSCALE);    cv::Mat src2 = cv::imread(\"path/to/src2\", cv::IMREAD_GRAYSCALE);    cv::Mat dst;    cv::addWeighted(src1, 0.4, src2, 0.6, 0, dst);    cv::imshow(\"debug\", dst);    cv::waitKey();    cv::dstroyAllWindows();    return 0;}subtract  빼기 연산.  add와 동일하나 subtract는 뺄셈이므로 src1과 src2의 순서에 따라 결괏값의 차이가 발생한다.  두 입력 영상의 타입이 동일하다면 - 연산자로 연산 수행이 가능하다.#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src1 = cv::imread(\"path/to/src1\", cv::IMREAD_GRAYSCALE);    cv::Mat src2 = cv::imread(\"path/to/src2\", cv::IMREAD_GRAYSCALE);    cv::Mat dst1, dst2;    cv::subtract(src1, src2, dst1);    cv::subtrack(src2, src1, dst2);    cv::Mat images;    cv::hconcat(std::vector&lt;cv::Mat&gt;({dst1, dst2}), images);    cv::imshow(\"debug\", images);    cv::waitKey();    cv::destroyAllWindows();    return 0;}absdiff  차연산.  뺄셈 순서에 상관 없이 두 입력 영상의 픽셀차가 큰 영역을 나타내기 위해 사용.  두 입력 영상의 차이값의 절댓값을 나타낸다.#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src1 = cv::imread(\"path/to/src1\", cv::IMREAD_GRAYSCALE);    cv::Mat src2 = cv::imread(\"path/to/src2\", cv::IMREAD_GRAYSCALE);    cv::Mat dst;    cv::absdiff(src1, src2, dst);        cv::imshow(\"debug\", dst);    cv::waitKey();    cv::destroyAllWindows();    return 0;}multiply, divide  곱셈, 나눗셈 연산.  실무에서 잘 사용하진 않으며 각 픽셀에 대한 연산을 수행한다."
  },
  
  {
    "title": "Expression: is_block_type_valid(header->_block_use)",
    "url": "/posts/cpp-error-2/",
    "categories": "Trouble Shooting",
    "tags": "cpp, trouble shooting",
    "date": "2023-12-31 00:00:00 +0900",
    





    
    "snippet": "문제비쥬얼 스튜디오에서 CPP 파일을 실행하는 도중 Expression: is_block_type_valid(header-&gt;_block_use)라는 메세지와 함께 에러가 발생했다.검색을 해보니 힙메모리에서 참조할 수 없는 데이터를 참조하려고 할 때 발생하는 문제였다.#define _CRT_SECURE_NO_WARNINGS#include &lt;i...",
    "content": "문제비쥬얼 스튜디오에서 CPP 파일을 실행하는 도중 Expression: is_block_type_valid(header-&gt;_block_use)라는 메세지와 함께 에러가 발생했다.검색을 해보니 힙메모리에서 참조할 수 없는 데이터를 참조하려고 할 때 발생하는 문제였다.#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstring&gt;class Person{private:\tchar* name;\tint age;public:\tPerson(const char* myname, int myage)\t{\t\tint len = strlen(myname) + 1;\t\tname = new char[len];\t\tstrcpy(name, myname);\t\tage = myage;\t}\tvoid ShowPersonInfo() const\t{\t\tstd::cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; std::endl;\t\tstd::cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; std::endl;\t}\t~Person()\t{\t\tdelete[]name;\t\tstd::cout &lt;&lt; \"called destructor\" &lt;&lt; std::endl;\t}};int main(void){\tPerson man1(\"MAN1 NAME\", 29);\tPerson man2(\"MAN2 NAME\", 22);\tman2 = man1;\tman1.ShowPersonInfo();\tman2.ShowPersonInfo();\treturn 0;}  위 코드에서 man1이 호출 된 뒤 소멸하는데 new를 통해 선언 된 name을 메모리 해제시킨다.  다음 호출 된 man2도 마찬가지로 소멸하면서 소멸자를 호출하는데, 이 때 man2는 대입연산자에 의해 man1과 같은 메모리를 가르키게 되므로 name을 해제할 수 없게 되었다.해결  얕은 복사가 이루어지며 발생한 문제이므로 대입연산을 진행할 때 깊은 복사를 할 수 있도록 지정하고 깊은 복사에 앞서 메모리 해제를 시킨다.Person&amp; operator=(const Person&amp; ref){    delete[]name;  // 메모리 누수를 막기 위한 메모리 해제    int len = strlen(ref.name) + 1;    name = new char[len];    strcpy(name, ref.name);    age = ref.age;    return *this;}Reference네이버 블로그"
  },
  
  {
    "title": "OpenCV 히스토그램",
    "url": "/posts/opencv-histogram/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.히스토그램  픽셀값의 분포를 나타낸다.  히스토그램 그래프의 가로축은 빈(bin) 이라 부른다.          그레이스케일의 경우 픽셀이 나타낼 수 있는 0 ~ 255 까지 총 256 개의 bin 이 존재한다.     ...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.히스토그램  픽셀값의 분포를 나타낸다.  히스토그램 그래프의 가로축은 빈(bin) 이라 부른다.          그레이스케일의 경우 픽셀이 나타낼 수 있는 0 ~ 255 까지 총 256 개의 bin 이 존재한다.      bin 의 갯수와 픽셀값의 범위가 항상 일치해야하는 것만은 아니다.                  bin 이 작을수록 더욱 대략적인 픽셀값의 분포를 나타내며, 그 반대는 좀 더 세밀한 픽셀값의 분포를 나타낸다.                    calcHist  영상의 히스토그램을 분석하는 함수.          단일 영상, 여러장의 영상      그레이스케일, 컬러스케일      bin 의 갯수 지정 가능        void calcHist(images, nimages, channels, mask, hist, dims, histSize, ranges, uniform = true, accumulate = false);          images: 입력 영상의 배열 또는 영상의 주소 (배열인 경우 모든 이미지의 크기와 채널이 동일해야함)      nimages: 입력 영상의 개수      chnnels: 히스토그램을 구할 채널을 나타내는 정수형 배열      mask: 마스크 영상. 입력 영상과 같은 크기의 배열이며, 원소값이 0 이 아닌 좌표의 값들만 계산에 사용 된다. cv::Mat()이나 cv::noArray()로 무시할 수 있다.      hist: 출력 히스토그램 CV_32FC1를 사용하는 행렬      dims: 출력 히스토그램 차원 수      histSize: 각 차원의 히스토그램 배열 크기 (각 차원의 bin 개수)      ranges: 각 차원의 히스토그램 범위.                  uniform = true(등간격) 인 경우 ranges[i]는 각 차원의 최소값과 최대값으로 구성 된 배열이며 [최소값, 최대값)을 나타냄.          uniform = false(비등간격) 인 경우 ranges[i]는 각각의 구역을 나타내는 histSize[i] + 1 개의 원소로 구성 된 배열.                    uniform: bin 간격이 균등한지 나타내는 플래그      accumulate: 누적 여부 플래그. true면 hist를 초기화하지 않고 누적하여 계산한다.      #include \"opencv2/opencv.hpp\"cv::Mat calcGrayHist(cv::Mat &amp;img);cv::Mat getGrayHist(cv::Mat &amp;hist);int main(void){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    cv::Mat hist = calcGrayHist(src);    cv::Mat histImage = getGrayHist(hist);    cv::imshow(\"src\", src);    cv::imshow(\"srcHist\", srcHist);    cv::waitKey();    return 0;}// 히스토그램 계산 함수cv::Mat calcGrayHist(cv::Mat &amp; img){    CV_Assert(img.type() == CV_8UC1);    cv::Mat hist;    int channels[] = { 0 };    int dims = 1;    const int histSize[] = { 256 };    float graylevel[] = {0, 256 };    const float* ranges[] = { graylevel };    cv::calcHist(&amp;img, 1, channels, cv::noArray(), hist, dims, histSize, ranges);    return hist;}// 히스토그램 출력 함수cv::Mat getGrayHist(cv::Mat &amp;hist){    CV_Assert(hist.type() == CV_32FC1);    CV_Assert(hist.size() == cv::Size(1, 256));    double histMax;    cv::minMaxLoc(hist, 0, &amp;histMax);  // 최소값은 제외, 최대값은 &amp;histMax 에 저장    cv::Mat imgHist(100, 256, CV_8UC1, cv::Scalar(255));    for (int i = 0; i &lt; 256; i++)    {        // 최대값은 길이가 100인 직선을 긋는다.        cv::line(imgHist, cv::Point(i, 100), cv::Point(i, 100 - cvRound(hist.at&lt;float&gt;(i, 0) * 100 / histMax)), cv::Scalar(0));    }  return imgHist;}히스토그램 스트레칭 (Histogram Stretching)  영상의 픽셀분포를 전 구간에 걸쳐 나타내도록하는 선형 변환 기법이다.  명암비가 낮은 이미지는 히스토그램이 특정 구간에 밀집 되어있는데, 이를 길게 늘리듯이 펼치는 방법이다.  히스토그램 스트레칭을 하면 전반적인 명암비가 높아지므로 대체로 품질이 좋아진다.  $dst(x,\\;y) = (\\frac{src(x, \\;y) - G_{min}}{G_{max} - G_{min}}) * 255 \\;(단, \\;G_{max}, \\;G_{min}은 \\;픽셀 \\;최대최소값)$          해당식은 $G_{min}$값은 0으로 $G_{max}$값은 255로 늘리면서 히스토그램을 늘려준다.        히스토그램 스트레칭에 대한 함수는 따로 제공하지 않으므로 직접 구현해야한다.#include \"opencv2/opencv.hpp\"cv::Mat calcGrayHist(cv::Mat &amp;src);  // 위 코드와 동일cv::Mat getGrayHist(cv::Mat &amp;hist);  // 위 코드와 동일void histogramStretching();int main(void){    histogramStretching();    return 0;}void histogramStretching(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    double gmin, gmax;  // 최소, 최대값    cv::minMaxLoc(src, &amp;gmin, &amp;gmax);    cv::Mat dst = ((src - gmin) * 255 / (gmax - gmin));    cv::imshow(\"src\", src);    cv::imshow(\"srcHist\", getGrayHist(calcGrayHist(src)));    cv::imshow(\"dst\", dst);    cv::imshow(\"dstHist\", getGrayHist(calcGrayHist(dst)));    cv::waitKey();}히스토그램 평탄화 (Histogram Equalize)  cv::equalizeHist(src, dst);의 형태이며, 그레이스케일만 입력 받는다.  스트레칭과 더불어 픽셀값 분포를 고르게하는 작업.  특정 영역에 뭉쳐있는 픽셀값들을 고르게 분포시켜준다.  누적 히스토그램 $H(g)$을 이용하여 평탄화한다.          $H(g) = \\sum\\limits_{0\\leqq{i}&lt;g}h(i)$                  위 수식의 값은 그레이스케일 픽셀의 최대값인 255 를 훨씬 넘으므로 정규화를 해야한다.          $dst(x, \\;y) = round(H(src(x, \\;y)) * \\frac{L_{max}}{N}) \\;(단, \\;L_{max}는 \\;영상이 \\;가질 \\;수 \\;있는 \\;최대 \\;밝기이며, \\;N은 \\;픽셀의 \\;갯수)$                    #include \"opencv2/opencv.hpp\"cv::Mat calcGrayHist(cv::Mat &amp;src);cv::Mat getGrayHist(cv::Mat &amp;hist);void histogramEqualize();int main(void){    histogramEqualize();    return 0;}void histogramEqualize(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    cv::Mat dst;    cv::equalize(src, dst);    cv::imshow(\"src\", src);    cv::imshow(\"srcHist\", getGrayHist(calcGrayHist(src)));    cv::imshow(\"dst\", dst);    cv::imshow(\"dstHist\", getGrayHist(calcGrayHist(dst)));    cv::waitKey();}"
  },
  
  {
    "title": "OpenCV 명암비 조절",
    "url": "/posts/opencv-contrast/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.영상의 명암비 조절  영상에서 밝은 영역과 어두운 영역 간의 차이를 명암비라고 한다.  명암비가 높은 영상은 어두운 영역과 밝은 영역의 차이가 크기 때문에 사물의 분간이 쉽고, 그 반대는 영상 전체가 흐릿하게 보이기 때문...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.영상의 명암비 조절  영상에서 밝은 영역과 어두운 영역 간의 차이를 명암비라고 한다.  명암비가 높은 영상은 어두운 영역과 밝은 영역의 차이가 크기 때문에 사물의 분간이 쉽고, 그 반대는 영상 전체가 흐릿하게 보이기 때문에 사물의 분간이 어렵다.          명암비가 크다고 무조건 좋은 것은 아니다. 반대로 명암비가 너무 크게 되면 디테일한 부분들도 다 날아갈 수 있다.        영상의 밝기 조절은 영상 전체에 덧셈 연산을 함으로써 균일하게 값이 증가하고 감소했지만, 명암비는 곱셈 연산으로 큰 값은 크게, 작은 값은 작게 증가한다.  $dst(x, y) = saturate(src(x, y) * a) \\;(단, \\;x, \\;y 는 \\;픽셀의 \\;좌표이며 \\;a 는 \\;명암비 \\;조절값)$          실수 $a$에 대해 $a &gt; 1$인 경우 명암비 증가, $a &lt; 1$인 경우 명암비 감소      e.g.) 입력 영상에 대해 픽셀값이 60, 100 인 경우 기존 픽셀값의 차이는 40.                  픽셀값을 전체 2배를 하면 값은 120, 100 이 되며 픽셀값의 차이는 80 이 된다. (명암비 증가)          반대로 픽셀값을 반으로 줄이면 30, 50 으로 픽셀값의 차이는 20 이 된다. (명암비 감소)                    영상에 단순 곱셈 연산으로 명암비 조절  단순히 영상에 실수를 곱하는 경우 영상 전체의 값이 증가하거나 감소하게 된다.  $a$의 값이 1 이상인 경우 픽셀값이 증가하게 되는데, 포화연산으로 최대값은 255를 넘을 수 없으므로 대부분의 픽셀이 255 값으로 수렴할 수도 있다.  따라서, 이와 같이 단순한 방법으로 명암비를 조절하는 것은 실무에서는 거의 사용하지 않는다.#include \"opencv2/opencv.hpp\"void contrast();int main(void){    contrast();    cv::waitKey();    cv::destroyAllWindows();    return 0;}void contrast(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    float a = 2.f;  // 명암비 조절값    cv::Mat dst = a * src;  // 전체 픽셀값을 2배해준다.    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);}명암비 조절의 효과를 증대시키기  명암비의 효과를 증대시키기 위해선 일괄적으로 실수를 곱해 명암비를 조절하는 것이 아닌, 밝은 곳은 밝게, 어두운 곳은 어둡게 만들어야한다.  밝고 어두운 기준을 어떻게 설정하느냐에 따라 명암비의 효과에 따른 영상의 품질이 크게 달라질 수 있다.          기준은 그레이스케일의 절반값인 128이 될 수도 있고 전체 영상의 평균 픽셀값이 될 수도 있다.        픽셀값이 기준보다 높으면 밝게, 낮으면 어둡게 만드는 방식을 이용한다.  $dst(x, \\;y) = satureate(src(x, \\;y) + (src(x, \\;y) - b)) \\;* \\;a \\;(단, \\;a는 -1 보다 \\;크거나 \\;같은 \\;실수이며, \\;b는 \\;픽셀값의 \\;기준)$          해당 식에서 $-1 \\leqq a &lt; 0$인 경우 픽셀값이 감소하고 $a &gt; 0$인 경우 픽셀값 증가      #include \"opencv2/opencv.hpp\"void contrast();int main(void){    contrast();    cv::waitKey();    cv::destroyAllWindows();    return 0;}void contrast(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    float alpha = 2.f;    cv::Mat dst = (src + (src - 128)) * alpha;  // 픽셀값 128 을 기준으로 높으면 값 증가, 낮으면 감소    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);}"
  },
  
  {
    "title": "OpenCV 밝기 조절",
    "url": "/posts/opencv-brightness/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.영상의 밝기 조절  영상의 모든 픽셀에 대해 값을 증가시키면 밝아지고 감소시키면 어두워진다.  $dst(x, y) = src(x, y) + n \\;(단, \\;x, \\;y 는 \\;픽셀의 \\;좌표이며 \\;n 은 \\;밝기 \\;...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.영상의 밝기 조절  영상의 모든 픽셀에 대해 값을 증가시키면 밝아지고 감소시키면 어두워진다.  $dst(x, y) = src(x, y) + n \\;(단, \\;x, \\;y 는 \\;픽셀의 \\;좌표이며 \\;n 은 \\;밝기 \\;조절값)$  단, 포화연산 (saturate) 으로 인해 픽셀값은 최소 0, 최대 255 를 넘을 수 없다.          255 를 넘어가는 연산을 하게 되면 255 로 유지, 0 밑으로 내려가는 연산을 하게 되면 0 으로 유지.      $dst(x, y) = saturate(src(x, y) + n)$      OpenCV 기본 연산  OpenCV에선 연산자 오버로딩이 되어있어 이미지 픽셀 연산에 대해선 자동으로 포화연산을 지원한다.  이후 나올 다른 방법들에 비해 자체적인 최적화를 통해 속도가 제일 빠르며 가독성 또한 가장 좋다.#include \"opencv2/opencv.hpp\"void brightness();int main(void){    brightness();    return 0;}void brightness(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    if (src.empty())    {        std::cerr &lt;&lt; \"Image Load Failed!\" &lt;&lt; std::endl;        return;    }    cv::Mat dst(src.rows, src.cols, src.type());  // src 와 동일한 크기의 행렬을 생성한다.        dst = src + 100;  // 밝기 100 증가    cv::imshow(\"src\", src);    cv::imshow(\"dst\", dst);    cv::waitKey();}  src 이미지에서 밝기를 증가시킨 이미지 dst를 만든다.  별도의 행렬을 만들지 않고 자기 자신의 밝기를 조절하는 경우엔 행렬을 추가로 생성하지 않고 덧셈할당(+=) 을 한다.          위 코드의 경우 src += 100;을 하면 된다.        연산자의 경우 연산자 오버로딩이 되어있기 때문에 포화연산이 자동으로 적용 되어 픽셀이 255 를 넘어가지 않는다.픽셀에 직접 접근하여 밝기 조절  특수한 상황에서 OpenCV의 함수 등을 사용하지 못하는 경우 픽셀에 직접 접근하여 밝기를 조절해야한다.  이 경우엔 포화연산을 직접 구현해야한다.          기본제공하는 포화연산 함수는 cv::saturate_cast&lt;uchar&gt;(cv::Mat::operator);의 형태이다.      직접 구현해야하는 경우는 v = cv::Mat::operator.at&lt;uchar&gt;(i, j) + 100;일 때, v &gt; 255? 255 : v &lt; 0? 0 : v;이다.      #include \"opencv2/opencv.hpp\"void brightness1();  // 포화연산 함수 사용void brightness2();  // 포화연산 직접 구현int main(void){    brightness1();    brightness2();    cv::destroyAllWindows();    return 0;}void brightness1(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    if (src.empty())    {        std::cerr &lt;&lt; \"Image Load Failed!\" &lt;&lt; std::endl;        return;    }    cv::Mat dst(src.rows, src.cols, src.type());    for (int i = 0; i &lt; src.rows; i++)    {        for (int j = 0; j &lt; src.cols; j++)        {            dst.at&lt;uchar&gt;(i, j) = cv::saturate_cast&lt;uchar&gt;(src.at&lt;uchar&gt;(i, j) + 100);        }    }    cv::imshow(\"src1\", src);    cv::imshow(\"dst1\", dst);    cv::waitKey();}void brightness2(){    cv::Mat src = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);    if (src.empty())    {        std::cerr &lt;&lt; \"Image Load Failed!\" &lt;&lt; std::endl;        return;    }    cv::Mat dst(src.rows, src.cols, src.type());    for (int i = 0; i &lt; src.rows; i++)    {        for (int j = 0; j &lt; src.cols; j++)        {            int v = src.at&lt;uchar&gt;(i, j) + 100;  // src 의 밝기를 100 조절함 값            dst.at&lt;uchar&gt;(i, j) = v &gt; 255 ? 255 : v &gt; 0 ? 0 : v;        }    }    cv::imshow(\"src2\", src);    cv::imshow(\"dst2\", dst);    cv::waitKey();}트랙바를 이용한 밝기 조절#include \"opencv2/opencv.hpp\"void brightness();void on_brightness(int pos, void* userdata);int main(void){    return 0;}void brightness(){    cv::Mat src = cv::imread(\"/path/to/image\", cv::IMREAD_GRAYSCALE);    if (src.empty())    {        std::cerr &lt;&lt; \"Image Load Failed!\" &lt;&lt; std::endl;        return;    }    cv::namedWindow(\"dst\");    cv::createTrackbar(\"Brightness\", \"dst\", 0, 100, on_brightness, (void*)&amp;src);    on_brightness(0, (void*)&amp;src);    cv::waitKey();}void on_brightness(int pos, void* userdata){    cv::Mat src = *(cv::Mat*)userdata;    cv::Mat dst = src + pos;    cv::imshow(\"dst\", dst);}  createTrackbar 함수 뒤에 on_brightness 함수를 호출하지 않으면 트랙바를 움직이기 전까지 dst가 나오질 않기 때문이다."
  },
  
  {
    "title": "OpenCV 그레이스케일",
    "url": "/posts/grayscale/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Grayscale  컬러값인 RGB를 갖지 않고 밝기값만 갖고 있는 $1$채널 이미지.  이미지 연산 등에서 주로 그레이스케일을 사용하는 이유는 컬러스케일에 비해 채널값이 하나이므로 메모리를 ${1} / {3}$ 만 사용...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Grayscale  컬러값인 RGB를 갖지 않고 밝기값만 갖고 있는 $1$채널 이미지.  이미지 연산 등에서 주로 그레이스케일을 사용하는 이유는 컬러스케일에 비해 채널값이 하나이므로 메모리를 ${1} / {3}$ 만 사용하기 때문에 훨씬 경제적이다.이미지를 불러올 때 처음부터 그레이스케일로 로드  cv::imread 함수를 사용할 때 플래그를 cv::IMREAD_GRAYSCALE로 지정해주면 된다.cv::Mat grayScaleImage = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);CV_8UC1 타입으로 생성  최초 행렬 생성시 CV_8UC1 타입으로 생성하면 그레이스케일로 생성 된다.cv::Mat grayScaleImage(480, 640, CV_8UC1);cv::cvtColor 함수를 통해 그레이스케일로 변환  이미 컬러스케일로 로드 되었거나 생성 된 이미지 등은 cv::cvtColor 함수를 통해 그레이스케일로 변경 할 수 있다.          함수의 플래그는 cv::COLOR_BGR2GRAY로 지정한다.      cv::Mat colorScaleImage = cv::imread(\"path/to/image\", cv::IMREAD_COLOR);  // 컬로스케일로 로드cv::Mat grayScaleImage;cv::cvtColor(colorScaleImage, grayScalImage, cv::COLOR_BGR2GRAY);그레이스케일 여부 확인  이미지의 타입을 통해 그레이스케일인지 확인할 수 있다.          cv::Mat::operator.type() 는 타입을 반환하며 해당 타입이 CV_8UC1인지 확인하면 된다.      cv::Mat colorScaleImage = cv::imread(\"path/to/image\", cv::IMREAD_COLOR);cv::Mat grayScaleImage = cv::imread(\"path/to/image\", cv::IMREAD_GRAYSCALE);std::cout &lt;&lt; (colorScaleImage.type() == CV_8UC1) &lt;&lt; std::endl;std::cout &lt;&lt; (grayScaleImage.type() == CV_8UC1) &lt;&lt; std::endl;// 0 (false)// 1 (true)"
  },
  
  {
    "title": "OpenCV 에서 제공하는 유용한 함수",
    "url": "/posts/opencv-useful-functions/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-28 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.OpenCV 에서 제공하는 유용한 함수들cv::sum()  행렬 원소들의 합  이미지의 채널 값에 따라 원소가 저장 됨. (B G R A)          channel 값이 1 (GRAY SCALE) 일 때, 값이 첫 ...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.OpenCV 에서 제공하는 유용한 함수들cv::sum()  행렬 원소들의 합  이미지의 채널 값에 따라 원소가 저장 됨. (B G R A)          channel 값이 1 (GRAY SCALE) 일 때, 값이 첫 번째 원소에 저장 된다. [N, 0, 0, 0]      channel 값이 3 (COLOR SCALE) 일 때, 값이 B G R 순서로 저장 된다. [B, G, R, 0]      cv:: mean()  cv::scalar mean = cv::mean(mat);  행렬 원소들의 평균, 마스크 연산 지원  cv::sum과 마찬가지로 채널 값에 따라 원소가 저장 되는 길이가 달라진다.cv::minMaxLoc()  cv::minMaxLoc(inputArray, &amp;minVal, &amp;maxVal, &amp;minPos, &amp;maxPos);  행렬 원소의 최소 / 최대값 및 좌표 정보 확인, 마스크 연산 지원  각 위치에 맞는 변수들의 주소값들을 전달해줘야 한다.          특정 값이 필요하지 않는다면 그 위치에 0 (NULL)을 넣는다.      #include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"path/to/img\", cv::IMREAD_GRAYSCALE);    double minVal, maxVal;  // 최소, 최대값    cv::Point minPos, maxPos;  // 최소, 최대값의 위치    cv::minMaxLoc(img, &amp;minVal, &amp;maxVal, &amp;minPos, &amp;maxPos);    cv::minMaxLoc(img, 0, 0, &amp;minPos, 0);  // minPos 만 필요한 경우    std::cout &lt;&lt; minVal &lt;&lt; std::endl;    std::cout &lt;&lt; maxVal &lt;&lt; std::endl;    std::cout &lt;&lt; minPos &lt;&lt; std::endl;    std::cout &lt;&lt; maxPos &lt;&lt; std::endl;    return 0;}cv::normalize()  cv::normalize(inputArray, outputArray, alpha, beta, norm_type, matrix_type);  행렬의 놈 (norm) 값을 정규화하거나 원소값 범위를 특정 범위로 정규화한다.  norm_type의 종류에 따라 동작이 결정 된다.          NORM_INF, NORM_L1, NNORM_L2, …      cvRound()  반올림 함수.  실수를 0.5 를 기준으로 반올림한다.  소숫점 아래의 값이 정확히 0.5 라면 가장 가까운 짝수로 반환한다.std::cout &lt;&lt; cvRound(2.5) &lt;&lt; std::endl;  // 2std::cout &lt;&lt; cvRound(2.51) &lt;&lt; std::endl;  // 3std::cout &lt;&lt; cvRound(3.4999) &lt;&lt; std::endl;  // 3std::cout &lt;&lt; cvRound(3.5) &lt;&lt; std::endl;  // 4std::cout &lt;&lt; cvRound(2) &lt;&lt; std::endl;  // 2CV_Assert, CV_DbgAssert  조건에 따라 에러를 발생시켜주는 함수.  CV_Assert(expr), CV_DbgAssert(expr)의 형태.          expr은 표현식, 조건문이며 해당 조건문이 false인 경우 에러를 발생시킨다.      CV_Assert의 경우 릴리스모드, 디버그모드 둘 다 사용 가능하다.      CV_DbgAssert의 경우 디버그모드에서만 사용 가능하다.      CV_Assert(1 == 0);  // 0 (false) 이므로 에러 발생CV_DbgAssert(1 == 0); // 0 (false) 이므로 에러 발생 (디버그 모드에서만 동작)cv::TickMeter  실행 시간을 측정해주는 함수.  cv::TickMeter 객체를 호출한 뒤 cv::TickMeter.start()로 측정 시작, cv::TickMeter.stop() 으로 측정 종료한다.  시간 측정을 정확히 하기 위해서는 릴리스 모드에서 측정해야한다.          디버그모드에서는 컴파일러 자체의 최적화 등이 동작하지않으며 추가적인 연산이 더 들어간다.        getTickCount() 함수로 컴퓨터 내부에서 수행 되는 클럭의 횟수를 센다. (int64 반환)  getTickFrequency() 함수를 통해 클럭 주파수 (초당 클럭 횟수) 를 반환한다.  cv::TickMeter.getTimeSec() 함수를 통해 연산 시간을 초 단위로 환산해서 반환한다.#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    cv::TickMeter tm;  // 시간 측정 연산자 생성    cv::Mat img = cv::imread(\"path/to/image\", cv::IMREAD_COLOR);    cv::Mat dst(img.rows, img.cols, img.type());    tm.start();  // 시작 측정 시작    for (int i = 0; i &lt; img.rows; i++)    {        for (int j = 0; j &lt; img.cols; j++)        {            dst.at&lt;uchar&gt;(i, j) = src.at&lt;uchar&gt;(i, j);        }    }    tm.stop()l  // 시간 측정 종료    std::cout &lt;&lt; \"time: \" &lt;&lt; tm.getTimeSec() &lt;&lt; \"sec.\" &lt;&lt; std::endl;    return 0;}"
  },
  
  {
    "title": "Norm",
    "url": "/posts/norm/",
    "categories": "Math, Linear Algebra",
    "tags": "math, linear algebra",
    "date": "2023-12-28 00:00:00 +0900",
    





    
    "snippet": "Norm  Normalization 의 약자가 아님.  $\\rVert x_p \\lVert = \\sqrt[p]{\\sum_{i}\\mid x_i\\mid^p}\\;where\\; p\\in\\mathbb{R}$          해당 공식에서 $p$는 차수를 의미하며 $p$가 1 이면 L1 Norm 이고 $p$가 2 이면 L2 Norm 이다.      $p = 1$ ...",
    "content": "Norm  Normalization 의 약자가 아님.  $\\rVert x_p \\lVert = \\sqrt[p]{\\sum_{i}\\mid x_i\\mid^p}\\;where\\; p\\in\\mathbb{R}$          해당 공식에서 $p$는 차수를 의미하며 $p$가 1 이면 L1 Norm 이고 $p$가 2 이면 L2 Norm 이다.      $p = 1$ 일 때 그래프를 그려보면 마름모꼴이 되고 $p = 2$ 의 그래프는 원이다가 그 이후 $p$가 커질수록 점점 사각형에 가까운 형태가 된다.        공간 상에서 벡터 (Vector) 의 총 길이를 나타낸다.          원점 $O$ 으로부터의 벡터 거리 혹은 크기        일반적으로 L0 Norm, L1 Norm, L2 Norm 등이 존재한다.L0 Norm  실제로는 Norm이 아님.  벡터의 0이 아닌 요소의 총 갯수.          $\\overrightarrow{V}(0, 0)$ 의 경우 는 $0$.      $\\overrightarrow{V}(0, 1)$ 의 경우는 $1$.      $\\overrightarrow{V}(0, 2)$의 경우는 $1$.                  벡터의 요소 중 $0$이 아닌 갯수는 $2$ 하나이므로 L0 Norm은 $1$이다.                    L1 Norm  맨하탄 거리.  벡터 요소에 대한 절댓값의 합.  요소의 값에 대한 변화를 파악할 수 있다.  이상치에 대한 영향을 크게 받지 않는다.  L1 regulization과 computer vision 분야에 주로 사용 된다.          Lasso 회귀에서 loss 값을 규제하는 방법으로 많이 사용한다.      import numpy as npu = np.array([3, -4])print(np.abs(u).sum())# 7L2 Norm  유클리디안 거리.  각 성분의 제곱의 합을 루트로 씌워준 값.  한 지점에서 다른 지점으로 갈 때의 가장 짧은 거리를 측정.  L2 regulization, KNN algorithm, K-means algorithm 등에 주로 사용 된다.          라플라스 근사와 Ridge 회귀 방법에서 사용한다.        가장 많이 사용 되지만 결과값이 왜곡 될 가능성이 존재한다.          값을 제곱해서 더해주기 때문에 분포에서 벗어난 값이 커져 전체에 영향을 주는 경우가 많이 발생하기 때문이다.      import numpy as npu = np.array([3, -4])print(np.linalg.norm(u))# 5.0L-infinity Norm  벡터에서 가장 큰 요소를 선택한다.  $X = [-6, 4, 2]$인 경우 L-infinity Norm은 가장 절대값이 큰 값인 $6$이 된다.ReferenceTech &amp; Issue Blog생각 정리SOOHOCODE"
  },
  
  {
    "title": "Docker 삭제 후 재설치",
    "url": "/posts/wsl-docker-reinstall/",
    "categories": "Docker",
    "tags": "linux, docker",
    "date": "2023-12-24 00:00:00 +0900",
    





    
    "snippet": "최근에 내가 모르는 도커 이미지와 컨테이너가 반복적으로 생성 되는 것을 확인했다.이유를 특정하기 어려웠으므로 일단 제일 간단한 방법인 삭제 후 재설치하는 방향으로 문제를 해결하였다.Docker 삭제  도커 엔진 삭제sudo apt-get purge -y docker-engine docker docker-ce docker-ce-cli docker.ios...",
    "content": "최근에 내가 모르는 도커 이미지와 컨테이너가 반복적으로 생성 되는 것을 확인했다.이유를 특정하기 어려웠으므로 일단 제일 간단한 방법인 삭제 후 재설치하는 방향으로 문제를 해결하였다.Docker 삭제  도커 엔진 삭제sudo apt-get purge -y docker-engine docker docker-ce docker-ce-cli docker.iosudo apt-get autoremove -y --purge docker-engine docker docker-ce docker.io  컨테이너, 이미지, 볼륨 등 사용자가 만든 파일 등 모두 삭제sudo rm -rf /var/lib/docker /etc/dockersudo rm /etc/apparmor.d/dockersudo groupdel dockersudo rm -rf /var/run/docker.sock  제일 위의 명령인 sudo rm -rf /var/lib/docker /etc/docker를 실행 할 때 rm: cannot remove '/var/lib/docker': Device or resource busy라는 에러 발생.cat /proc/mounts | grep dockersudo umount /path  해당 명령어로 해결Docker 재설치  Docker official website 에서 설치하거나  sudo apt-get install docker-ce docker-ce-cli containerd.io로 설치한다.          필요에 따라 sudo apt-get install docker-compose로 docker compose도 설치해준다.      Reference히비스커스의 블로그github issues"
  },
  
  {
    "title": "연산자 오버로딩",
    "url": "/posts/cpp-operator-overloading/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-12-16 00:00:00 +0900",
    





    
    "snippet": "연산자 오버로딩  +, -, *, /, +=, -=, ==, !=, ... 등 숫자등을 연산하는 연산자 함수의 오버로딩이 가능하다.  해당 함수들을 오버로딩하는 것으로 객체간의 오버로딩도 가능하게 된다.연산자 오버로딩의 형태  operator 함수로 오버로딩          operator+, operator- …      멤버변수로만 오버로딩 가능한...",
    "content": "연산자 오버로딩  +, -, *, /, +=, -=, ==, !=, ... 등 숫자등을 연산하는 연산자 함수의 오버로딩이 가능하다.  해당 함수들을 오버로딩하는 것으로 객체간의 오버로딩도 가능하게 된다.연산자 오버로딩의 형태  operator 함수로 오버로딩          operator+, operator- …      멤버변수로만 오버로딩 가능한 연산자  연산자 오버로딩은 전역함수, 멤버함수로 오버로딩이 가능한데, 이때 멤버함수로만 오버로딩 할 수 있는 연산자가 존재한다.          객체를 대상으로 진행해야 의미가 있기 때문이다.      =(대입)      ()(함수 호출)      [](배열 접근 (인덱스))      -&gt;(멤버 접근을 위한 포인터)      오버로딩 할 수 없는 연산자  모든 연산자를 오버로딩할 수 있는 것은 아니다.          .(멤버 접근), .*(멤버 포인터)      ::(범위 지정)      ?:(조건 연산자 (3항 연산자))      sizeof(바이트 단위 크기 계산), typeid(RTTI 관련 연산자)      static_cast, dynamic_cast, const_cast, reinterpret_cast (형변환 연산자들)      #include &lt;iostream&gt;class Point{    private:        int xpos, ypos;    public:        Point(int x = 0, int y = 0)            : xpos(x), ypos(y)        { }        void ShowPosition()        {            std::cout &lt;&lt; xpos &lt;&lt; \", \" &lt;&lt; ypos &lt;&lt; std::endl;        }        Point operator+=(const Point &amp;pos)        {            xpos += pos.xpos;            ypos += pos.ypos;            return *this;        }        Point operator-=(const Point &amp;pos)        {            xpos -= pos.xpos;            ypos -= pos.ypos;            return *this;        }        friend Point operator-(const Point &amp;pos1, const Point &amp;pos2);        friend bool operator==(const Point &amp;pos1, const Point &amp;pos2);        friend bool operator!=(const Point &amp;pos1, const Point &amp;pos2);};Point operator-(const Point &amp;pos1, const Point &amp;pos2){    int x, y;    x = pos1.xpos - pos2.xpos;    y = pos1.ypos - pos2.ypos;    return Point(x, y);}bool operator==(const Point &amp;pos1, const Point &amp;pos2){    if (pos1.xpos == pos2.xpos &amp;&amp; pos1.ypos == pos2.ypos)    {        return true;    }    return false;}bool operator!=(const Point &amp;pos1, const Point &amp;pos2){    if (!(operator==(pos1, pos2)))    {        return true;    }    return false;}int main(void){    Point pos1(3, 4);    Point pos2(10, 20);    Point pos3(3, 4);    std::cout &lt;&lt; (pos1 == pos2) &lt;&lt; std::endl;    std::cout &lt;&lt; (pos1 == pos3) &lt;&lt; std::endl;    std::cout &lt;&lt; (pos2 == pos3) &lt;&lt; std::endl;    std::cout &lt;&lt; (pos1 != pos2) &lt;&lt; std::endl;    std::cout &lt;&lt; (pos1 != pos3) &lt;&lt; std::endl;    std::cout &lt;&lt; (pos2 != pos3) &lt;&lt; std::endl;    pos1.ShowPosition();    pos1 += pos2;    pos1.ShowPosition();    pos2.ShowPosition();    pos2 -= pos3;    pos2.ShowPosition();    Point pos4 = pos1 - pos2;    Point pos5 = pos1 - pos3;    pos4.ShowPosition();    pos5.ShowPosition();    return 0;}  -, ==, !=, +=, -= 등을 오버로딩.  연산자 함수를 오버로딩함으로써 Point 객체간의 연산 및 비교가 가능해졌다.단항 연산자의 오버로딩  피연산자가 두 개 이상인 이항 연산자와 피연산자가 한 개인 단항 연산자의 가장 큰 차이점은 피연산자의 개수.  매개변수의 개수에서 두 연산자 사이의 차이가 발생한다.증가, 감소 연산자  대표적인 단항 연산자.  1 증가 연산자인 ++ 와 1 감소 연산자인 --.  멤버함수로써의 연산자 오버로딩은 위 코드를 기준으로 pos1.operator++()          전달할 인자가 없는 이유는 단항 연산자를 오버로딩했기 때문이다.      하나있는 피연산자의 멤버함수를 호출하는 형태이기 때문.        전역함수로써의 연산자 오버로딩은 operator++(pos1)이 된다.          피연산자가 모두 인자로 전달 되므로 인자로 객체를 전달해줘야한다.      // ++, --#include &lt;iostream&gt;class Point{    private:        int xpos, ypos;    public:        Point(int x = 0, int y = 0)            : xpos(x), ypos(y)        {   }        void ShowPosition() const        {            std::cout &lt;&lt; \"[\" &lt;&lt; xpos &lt;&lt; \", \" &lt;&lt; ypos &lt;&lt; \"]\" &lt;&lt; std::endl;        }        Point&amp; operator++()  // 멤버함수이므로 인자 전달 안 함        {            xpos += 1;            ypos += 1;            return *this;  // 자기 자신을 반환        }        friend Point &amp;operator--(Point &amp;ref);  // 전역함수이므로 인자 전달};Point&amp; operator--(Point &amp;ref){    ref.xpos -= 1;    ref.ypos -= 1;    return ref;}int main(void){    Point pos(1, 2);    ++pos;    pos.ShowPosition();    --pos;    pos.ShowPosition();    ++(++pos); // ++(pos.operator++) -&gt; (pos의 참조값).operator++(); 의 형태    pos.ShowPosition();    --(--pos); // operator-- 연산자는 &amp;ref 를 인자로 받고 참조형으로 다시 반환하므로 operator--(pos의 참조값); 의 형태가 된다.    pos.ShowPosition();    return 0;}// 부호연산자 - 를 멤버함수로 오버로딩// 비트연산자 ~ 를 전역함수로 오버로딩 (xpos엔 y가 ypos엔 x가 들어가는 식으로)#include &lt;iostream&gt;class Point{    private:        int xpos, ypos;    public:        Point(int x = 0, int y = 0)            :xpos(x), ypos(y)        {    }        void ShowPosition() const        {            std::cout &lt;&lt; \"[\" &lt;&lt; xpos &lt;&lt; \", \" &lt;&lt; ypos &lt;&lt; \"]\" &lt;&lt; std::endl;        }        Point operator-()        {            Point pos(-xpos, -ypos);            return pos;        }        friend Point operator~(const Point &amp;);};Point operator~(const Point &amp;ref){    Point pos(ref.ypos, ref.xpos);    return pos;}int main(void){    Point pos1(3, 4);    Point pos2 = -pos1;    pos1.ShowPosition();    pos2.ShowPosition();    pos2 = ~pos1;    pos1.ShowPosition();    pos2.ShowPosition();    return 0;}전위 증가와 후의 증가의 구분  후위증가의 경우 pos.operatr++(int)의 형태로 정의한다.  int는 후위연산을 구분하기 위한 목적일 뿐 데이터를 전달하지는 않는다.  연산자 오버로딩을 할 때에 반환형은 const로 한다.          이는 임시로 생성하여 반환하는 객체를 const 형태로 하겠다는 것.      임시로 생성 되는 객체는 pos 객체에서 저장 된 값의 변경은 하지 않겠다는 것이다.      const 로 선언 된 객체는 const로 선언 된 함수만 사용 가능하기 때문.      #include &lt;iostream&gt;class Point{    private:        int xpos, ypos;    public:        Point(int x = 0, int y = 0)            : xpos(x), ypos(y)        { }        void ShowPosition() const        {            std::cout &lt;&lt; xpos &lt;&lt; \", \" &lt;&lt; ypos &lt;&lt; std::endl;        }        Point&amp; operator++()  // 전위 증가        {            xpos += 1;            ypos += 1;            return *this;        }        const Point operator++(int)  // 후위 증가        {            const Point retobj(xpos, ypos); // const Point retobj(*this);            xpos += 1;  // 위 쪽의 새로운 객체를 만든 뒤 연산            ypos += 1;            return retobj;        }        friend Point&amp; operator--(Point &amp;ref);  // 전역 함수 전위 감소        friend const Point operator--(Point &amp;ref, int);  // 전역 함수 후위 감소};Point&amp; operator--(Point &amp;ref){    ref.xpos -= 1;    ref.ypos -= 1;    return ref;}const Point operator--(Point &amp;ref, int)// 반환형이 const 인 이유는 함수의 반환으로 생성 되는 임시 객체를 const 로 생성하겠단 의미// 저장 된 값의 변경을 허용하지 않겠다는 의미이며 const 로 선언 되지 않은 함수의 호출은 허용하지 않음{    const Point retobj(ref.xpos, ref.ypos);    ref.xpos -= 1;    ref.ypos -= 1;    return retobj;}int main(void){    Point pos(3, 5);    Point cpy;    cpy = pos--;    cpy.ShowPosition();    pos.ShowPosition();    cpy = pos++;    cpy.ShowPosition();    pos.ShowPosition();    return 0;}"
  },
  
  {
    "title": "undefined reference to `std::ostream::operator<<(std::ostream& (*)(std::ostream&))'",
    "url": "/posts/cpp-error-1/",
    "categories": "Trouble Shooting",
    "tags": "cpp, trouble shooting",
    "date": "2023-12-14 00:00:00 +0900",
    





    
    "snippet": "문제undefined reference to std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))'라는 메세지와 함께 컴파일이 되지 않았다.#include &lt;iostream&gt;도 제대로 선언했었고, namespace도 제대로 지정해주었으나, 계속 같은 문제가 발생하였...",
    "content": "문제undefined reference to std::ostream::operator&lt;&lt;(std::ostream&amp; (*)(std::ostream&amp;))'라는 메세지와 함께 컴파일이 되지 않았다.#include &lt;iostream&gt;도 제대로 선언했었고, namespace도 제대로 지정해주었으나, 계속 같은 문제가 발생하였다.해결검색을 해보니 컴파일러의 지정이 제대로 되어있지 않았던 문제였다.tasks.json을 가보니 command 블럭에 /usr/bin/gcc로 되어있는 것을 확인했다./usr/bin/g++로 수정하여 c++로 컴파일하도록 수정하는 것으로 정상작동하는 것을 확인하였다.{  \"tasks\": [    {      \"type\": \"cppbuild\",      \"label\": \"C/C++: gcc 활성 파일 빌드\",      \"command\": \"/usr/bin/g++\",      \"args\": [        \"-fdiagnostics-color=always\",        \"-g\",        \"${file}\",        \"-o\",        \"${fileDirname}/${fileBasenameNoExtension}\"      ],      \"options\": {        \"cwd\": \"${fileDirname}\"      },      \"problemMatcher\": [\"$gcc\"],      \"group\": {        \"kind\": \"build\",        \"isDefault\": true      },      \"detail\": \"디버거에서 생성된 작업입니다.\"    }  ],  \"version\": \"2.0.0\"}Reference기린의 공부 블로그"
  },
  
  {
    "title": "OpenCV 트랙바 생성",
    "url": "/posts/opencv-trackbar/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-12 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.트랙바 생성  트랙바 관련 콜백 함수cv::createTrackbar를 cv::setTrackbarPos 함수에 전달한다.  cv::createTrackbar(trackbar name, window name, pos, l...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.트랙바 생성  트랙바 관련 콜백 함수cv::createTrackbar를 cv::setTrackbarPos 함수에 전달한다.  cv::createTrackbar(trackbar name, window name, pos, level, call back function, image);          pos는 트랙바가 어디서 시작할지를 지정한다.        콜백 함수 내에서는 cv::getTrackbarPos 함수를 통해 트랙바가 위치한 윈도우에서 값을 받아온다.#include \"opencv2/opencv.hpp\"void on_level_change(int pose, void* userdata);  // 콜백 함수 선언cv::Mat img = cv::Mat::zeros(400, 600, CV_8UC1);  // 전역변수로 선언int pos = 0;  // 시작점int main(void){    cv::namedWindow(\"debug\");  // 이미지를 출력 할 윈도우 설정    cv::createTrackbar(\"level\", \"debug\", &amp;pos, 16, on_level_change, (void*)&amp;img);    cv::setTrackbarPos(\"level\", \"debug\", 2);    return 0;}void on_level_change(int pose, void* userdata){    cv::Mat img = *(cv::Mat*)usedata;    img.setTo(pose * 16);  // 트랙바가 1단계씩 커질 때마다 프레임 전체 값에 += 16        cv::imshow(\"debug\", img);    pose = cv::getTrackbarPos(\"level\", \"debug\");}"
  },
  
  {
    "title": "OpenCV 마스크 연산",
    "url": "/posts/opencv-mask/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-12 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.마스크 연산      영상 (프레임), 이미지 등의 일부 영역에 대해서만 특정 연산을 수행하는 것.        주로 영상을 그레이스케일로 변환한 뒤 연산한다.  setTo  operator::Mat.setTo(마스크 값...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.마스크 연산      영상 (프레임), 이미지 등의 일부 영역에 대해서만 특정 연산을 수행하는 것.        주로 영상을 그레이스케일로 변환한 뒤 연산한다.  setTo  operator::Mat.setTo(마스크 값, 마스크 행렬);의 형태#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src = cv::imread(\"lenna.bmp\", cv::IMREAD_COLOR);    cv::Mat mask = cv::imread(\"mask_smile.bmp\", cv::IMREAD_GRAYSCALE);    src.setTo(cv::Scalar(0, 255, 255), mask);    cv::imshow(\"debug\", src);    cv::waitKey();    cv::destroyAllWindows();    return 0;}  lenna.bmp에 mask_smile.bmp 영역을 합성한다.copyTo  복사 할 행렬만 전달하면 단순 행렬 복사한다.  복사 할 행렬과 마스크 연산을 입력으로 받으면 마스크 연산을 수행한다.  마스크 영역의 행렬값들을 dst 행렬로 복사한다.          마스크 영역에 있는 값들은 $0$ 혹은 $255$ 이며 copyTo를 통해 $0$이 아닌 값들만 dst 행렬로 복사한다.      $0$이 아닌 위치의 값들만 복사 되었기 때문에 해당 영역의 그람만 합성 된다.      #include \"opencv2/opencv.hpp\"int main(void){    cv::Mat src = cv::imread(\"airplane.bmp\", cv::IMREAD_COLOR);    cv::Mat mask = cv::imread(\"mask_plane.bmp\", cv::IMREAD_GRAYSCALE);    cv::dst = cv::imread(\"field.bmp\", cv::IMREAD_COLOR);    src.copyTo(dst, mask);    cv::imshow(\"debug\", dst);    cv::waitKey();    cv::destroyAllWindows();}  airplane.bmp의 비행기 영역을 지정 ($0$이 아닌 값의 위치)하여 마스크를 생성한 뒤 해당 영역의 행렬값만 복사하여 field.bmp에 합성한다.  field.bmp에 airplane.bmp의 비행기 영역의 값들이 복사 되어 합성 됨."
  },
  
  {
    "title": "OpenCV 파일 입출력",
    "url": "/posts/opencv-io/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-12 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.파일 입출력  uchar를 사용하는 이미지 뿐만 아니라 int, double 등을 사용하는 일반 배열의 행렬도 저장 가능히디.  json 형식의 파일도 저장 가능하다.  cv::FileStorage 함수로 변수 선언한다....",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.파일 입출력  uchar를 사용하는 이미지 뿐만 아니라 int, double 등을 사용하는 일반 배열의 행렬도 저장 가능히디.  json 형식의 파일도 저장 가능하다.  cv::FileStorage 함수로 변수 선언한다.  cv::FileStorage 함수의 flag로 파일을 읽을 것인지 쓸 것인지를 지정한디.          flag에는 cv::FileStorage::READ와 cv::FileStorage::WRITHE가 있다.        파일을 읽고 쓰고 난 다음에는 항상 release() 함수를 사용한다.#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;#include &lt;string&gt;int main(void){    cv::FileStorage fs(\"./path/to/read/file.json\", cv::FileStorage::READ);        std::string name;    fs[\"name\"] &gt;&gt; name;  // &gt;&gt; 연산자로 파일에 저장    fs.release();    cv::FileStorage fs2(\"./path/top/write/file.json\", cv::FileStorage::WRITE);    fs2 &lt;&lt; \"name\" &lt;&lt; \"different name\";    fs2 &lt;&lt; \"birth\" &lt;&lt; 30;  // birth 라는 키를 추가하고 30 이라는 밸류 삽입    fs2.release();    return 0;}"
  },
  
  {
    "title": "OpenCV 마우스 이벤트",
    "url": "/posts/opencv-mouse-event/",
    "categories": "CPP, OpenCV",
    "tags": "",
    "date": "2023-12-07 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.마우스 이벤트  마우스 콜백함수를 정의한 뒤 cv::setMouseCallback() 함수에 전달한다.  마우스 이벤트에는 왼쪽, 오른족, 가운데 버튼 등을 지정할 수 있고 업, 다운, 클릭, 드래그 등이 있다.  cv:...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.마우스 이벤트  마우스 콜백함수를 정의한 뒤 cv::setMouseCallback() 함수에 전달한다.  마우스 이벤트에는 왼쪽, 오른족, 가운데 버튼 등을 지정할 수 있고 업, 다운, 클릭, 드래그 등이 있다.  cv::setMouseCallback(window name, call-back function);#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;cv::Mat img;  // 전역 변수로 이미지 선언cv::Point pt;  // 전역 변수로 좌표를 담을 변수 선언void onMouse(int event, int x, int y, int flags, void*);  // 마우스 이벤트 콜백 함수 선언int main(void){    img = cv::imread(\"./path/to/image\");    cv::namedWindow(\"debug\");  // 창을 출력할 윈도우 이름 지정    cv::setMouseCallback(\"debug\", onMouse);  // 마우스 좌표를 입력 받을 윈도우, 입력 받은 좌표와 플래그로 어떤 일을 할지에 대한 이벤트 처리 함수 전달    cv::imshow(\"debug\", img);    cv::waitKey();    cv::destroyAllWindows();    return 0;}void onMouse(int event, int x, int y, int flags, void*)  // 함수 정의{    switch(event)    {        case cv::EVENT_LUBTTONDOWN:  // 왼버튼 누르기            pt = cv::Point(x, y);  // 함수로부터 전달 받은 좌표값 지정            break;        case cv::EVENT_LBUTTONUP:  // 왼버튼 떼기            break;        case cv::EVENT_MOUSEMOVE:  // 마우스 드래그 (움직이기)            if(flags &amp;cv::EVENT_FLAG_LBUTTON)  // 마우스의 왼쪽 버튼의 이벤트가 발생한 경우            {                cv::line(img, pt, cv::Point(x, y), cv::Scalar(0, 255, 0), 2);  // 직전에 저장 되어있던 좌표와 현재 좌표를 연결하는 직선을 그림                cv::imshow(\"debug\", img);                pt = cv::Point(x, y);  // 움직이며 발생하는 좌표들로 계속 초기화            }            break;        default:            break;    }}"
  },
  
  {
    "title": "OpenCV 비디오 다루기",
    "url": "/posts/opencv-video-handling/",
    "categories": "",
    "tags": "cpp, opencv, book review",
    "date": "2023-12-05 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Video Capture  영상 파일을 불러오거나 장치에 연결 되어있는 카메라에서 이미지 (프레임) 을 받아옴  영상 파일을 불러올 때엔 cv::VideoCapture cap(\"./path/to/file\");을  장치에 ...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Video Capture  영상 파일을 불러오거나 장치에 연결 되어있는 카메라에서 이미지 (프레임) 을 받아옴  영상 파일을 불러올 때엔 cv::VideoCapture cap(\"./path/to/file\");을  장치에 연결 된 카메라에서 프레임을 불러올 때에는 cv::VideoCapture cap(0);을 입력한다.          0은 장치에 연결 된 0번째 카메라라는 의미이며, 연결 된 장치가 늘어날 수록 index 도 늘어난다.        cv::VideoCapture 클래스를 초기화하기 위한 방법은 두 가지.          선언과 동시에 초기화      선언만 한 뒤 .open() 함수로 초기화        .isOpend() 함수로 현재 영상이나 카메라가 열려있는지 확인 가능  .read(frame) 함수로 미리 설정 된 frame이란 cv::Mat 변수에 불러온 이미지 대입 가능          cv::VideoCapture::operator &gt;&gt; frame 으로 &gt;&gt; 연산자를 통해 대입 가능        비디오 캡처에 대한 모든 작업이 완료 되었으면 release() 함수를 이용해 메모리에서 제거한다.영상 정보 얻기  .get(flag) 함수로 영상에 대한 정보를 얻을 수 있음          cv::CAP_PROP_FPS; 영상의 fps를 얻음      cv::CAP_PROP_FRAME_WIDTH; 영상의 width 를 얻을 수 있음        .set(flag) 함수로 영상에 대한 정보값을 세팅할 수 있음#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    cv::Mat frame;    cv::VideoCapture cap(0);  // 선언과 동시에 초기화    // cv::VideoCapture cap();    // cap.open(0);  // 선언 후 open 함수를 통한 초기화    if(!cap.isOpened())    {        std::cerr &lt;&lt; \"the video has not ready.\";        return -1;  // 영상이 열리지 않았으면 종료    }    while(cap.isOpened())    {        cap &gt;&gt; frame;        cap.read(frame);  // 미리 선언 한 frame 에 read 한 이미지 대입        std::cout &lt;&lt; \"Frame size is \" &lt;&lt; cap.get(cv::CAP_PROP_FRAME_WIDTH) &lt;&lt; \", \" &lt;&lt; cap.get(cv::CAP_PROP_FRAME_HEIGHT) &lt;&lt; std::endl;        if(!frame.rows &gt; 0)        {            std::cout &lt;&lt; \"video is over.\" &lt;&lt; std::endl;            break;        }        cv::imshow(\"debug\", frame);        if(cv::waitKey(cap.get(cv::CAP_PROP_FPS)) == 27)        {            break;        }    }    cv::destroyAllWindows();    cv::release();    return 0;}Video Writer  이미지나 영상의 프레임을 영상의 형태로 저장하는 클래스  cv::VideoWriter::fourcc(codec name(4 char));로 저장할 비디오의 코덱 형식을 지정          int 형식의 4개의 숫자        cv::VideoWriter wrt; 선언을 통해 VideoWriter 객체를 선언하고 wrt.open();을 통해 초기화한다.          wrt.open(\"path/to/file_name\", fourcc, fps, size);      cv::Size(width, height)        프레임을 저장할 땐 write() 함수를 사용하거나 재정의 된 &lt;&lt; 연산자를 이용한다.  모든 처리가 끝나면 마찬가지로 release() 함수를 실행한다.#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){  cv::Mat frame;  cv::Mat outFrame;  cv::VideoCapture cap(\"./path/to/video\");  // 프레임을 캡처 할 카메라, 혹은 영상 파일  cv::VideoWriter wrt;  int fourcc = cv::VideoWriter::fourcc('X', 'V', 'I', 'D');  // 코덱 정의  wrt.open(\"./path/to/save/file\", fourcc, cap.get(cv::CAP_PROP_FPS), cv::Size(cap.get(cv::CAP_PROP_FRAME_WIDTH), cap.get(cv::CAP_PROP_FRAME_HEIGHT)));  while(cap.isOpened())  {    cap &gt;&gt; frame;    if(!cap.rows &gt; 0)    {      break;    }    wrt &lt;&lt; frame;  // 저장    // wrt.write(frame);  으로도 지정 가능  }  wrt.release();  cap.release();  return 0;}"
  },
  
  {
    "title": "OpenCV Vec Scalar",
    "url": "/posts/opencv-vec-scalar/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Vec 클래스  OpenCV에서 지원하는 데이터 타입  특정 벡터에 접근할 수 있는 .val() 멤버 함수 존재          [] 연산자 재정의로 vector.val(int x)를 vector[int x]로 접근 가능...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Vec 클래스  OpenCV에서 지원하는 데이터 타입  특정 벡터에 접근할 수 있는 .val() 멤버 함수 존재          [] 연산자 재정의로 vector.val(int x)를 vector[int x]로 접근 가능함      #include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    cv::Vec3b p1, p2(0, 0, 255);  // 벡터 선언    std::cout &lt;&lt; p1 &lt;&lt; std::endl;  // [0, 0, 0]으로 초기화    std::cout &lt;&lt; p2 &lt;&lt; std::endl;  // [0, 0, 255]으로 초기화    p1.val(0) = 100;  // p1의 0번째 원소값에 100 대입    p1[1] = 100;  // p1의 1번째 원소값이 100 대입    std::cout &lt;&lt; p1 &lt;&lt; std::endl;  // [100, 100, 0]으로 변경    return 0;}Scalar_ 클래스  원래 모양은 Scalar_&lt;typename T&gt;으로 선언하나 자주 사용하는 타입은 템플릿으로 재정의  Scalar 클래스는 4개 이하의 채널을 갖는 영상 혹은 이미지의 픽셀값을 표현하는 용도로 많이 사용          크기가 4인 double 형태의 배열을 갖는 자료형      4개 이하인 채널의 영상값을 표현할 땐 RGBa 값으로 표현      #include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;void ScalarOp();int main(void){    ScalarOp();    return 0;}void ScalarOp(){    cv::Scalar gray = 128;  // [128, 0, 0, 0] 행렬 생성    std::cout &lt;&lt; \"gray: \" &lt;&lt; gray &lt;&lt; std::endl;    cv::Scalar yellow(0, 255, 255);  // [0, 255, 255, 0] 행렬 생성    std::cout &lt;&lt; \"yellow: \" &lt;&lt; yellow &lt;&lt; std::endl;    cv::Mat img1(256, 256, CV_8UC3, yellow);  // 256 x 256 크기에 yellow 대입해 선언    for(int i = 0; i &lt; 4; i++)    {        std::cout &lt;&lt; yellow[i] &lt;&lt; std::endl;  // Scalar 클래스도 Vec 클래스처럼 [] 연산자로 접근 가능    }}/*gray: [128, 0, 0, 0]yellow: [0, 255, 255, 0]02552550*/"
  },
  
  {
    "title": "OpenCV 행렬 계산",
    "url": "/posts/opencv-mat_calc/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.행렬 연산  행렬과 스칼라간의 합, 곱  행렬과 행렬간의 합, 곱 (수학적인 곱, 같은 위치의 원소간의 곱)  역행렬  전치행렬 등역행렬  정방형의 행렬 $A$에 대해 $A$의 역행렬 $A^{-1}$과의 곱 $AA^{-1...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.행렬 연산  행렬과 스칼라간의 합, 곱  행렬과 행렬간의 합, 곱 (수학적인 곱, 같은 위치의 원소간의 곱)  역행렬  전치행렬 등역행렬  정방형의 행렬 $A$에 대해 $A$의 역행렬 $A^{-1}$과의 곱 $AA^{-1}$은 단위 행렬 $E$가 나옴  cv::Mat.inv()로 역행렬 생성#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    float data[] = {1, 2, 3, 4};    cv::Mat mat1(2, 2, CV_8UC1, data);  // 행렬 선언 및 초기화    cv::Mat mat2 = mat1.inv();  // mat1 에 대한 역행렬 생성        std::cout &lt;&lt; \"mat1:\\n\" &lt;&lt; mat1 &lt;&lt; std::endl;    std::cout &lt;&lt; \"mat2:\\n\" &lt;&lt; mat2 &lt;&lt; std::endl;    std::cout &lt;&lt; \"mat1 * mat2:\\n\" &lt;&lt; mat1 * mat2 &lt;&lt; std::endl;    return 0;}/*mat1:[1, 2; 3, 4]mat2:[-2, 1; 1.5, -0.5]mat1 * mat2:[1, 0; 0, 1]*/전치행렬  행렬의 행과 열의 순서를 바꿈  cv::Mat.t()의 형태로 선언#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    float data[] = {2, 3, 4, 5};    cv::Mat mat1(2, 2, CV_8UC1, data);    cv::Mat mat2 = mat1.t();  // 전치 행렬 생성    std::cout &lt;&lt; \"mat1:\\n\" &lt;&lt; mat1 &lt;&lt; std::endl;    std::cout &lt;&lt; \"mat2:\\n\" &lt;&lt; mat2 &lt;&lt; std::endl;    return 0;}/*mat1:[2, 3; 4, 5]mat2:[2, 4; 3, 5]*/행렬의 곱  $A * B$와 cv::Mat.mul(cv::Mat)이 존재  $A * B$는 수학적인 행렬의 곱이고 mul함수는 같은 위치의 원소끼리의 곱셈이다#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    float data1[] = {1, 2, 3, 4};    float data2[] = {2, 3, 4, 5};    cv::Mat mat1(2, 2, CV_8UC1, data1);    cv::Mat mat2(2, 2, CV_8UC1, data2);    std::cout &lt;&lt; \"mat1 * mat2:\\n\" &lt;&lt; mat1 * mat2 &lt;&lt; std::endl;    std::cout &lt;&lt; \"mat1.mul(mat2):\\n\" &lt;&lt; mat1.mul(mat2) &lt;&lt; std::endl;    return 0;}/*mat1 * mat2:[10, 13; 22, 29]mat1.mul(mat2):[2, 6, 12, 20]*/"
  },
  
  {
    "title": "OpenCV 행렬 변환",
    "url": "/posts/opencv-convert-mat/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-29 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.행렬의 데이터 타입 변경  cv::Mat.convertTo(cv::Mat, type)의 형태  행렬 전체의 데이터타입을 변환시킨다#include \"opencv2/opencv.hpp\"#include &lt;iostream&...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.행렬의 데이터 타입 변경  cv::Mat.convertTo(cv::Mat, type)의 형태  행렬 전체의 데이터타입을 변환시킨다#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    float data[] = {1, 2, 3, 4};    cv::Mat mat1(2, 2, CV_32FC1, data);  // 32bit float 타입의 행렬 생성    cv::Mat mat2;  // 빈 행렬 생성    mat1.convertTo(mat2, CV_8UC1);  // 32bit float 타입의 행렬 mat1 을 8bit uchar 타입의 행렬로 변환후 mat2 에 복사    return 0;}행렬의 모양 변경  cv::Mat.reshape(channel, rows)의 형태  행렬의 행을 기준으로 모양을 변경          channel의 값이 0 이면 채널값은 변경 안 함      rows의 값이 0 이면 행 값은 변경 안 함        reshape 함수의 반환행렬의 원소값을 변경하면 원본 행렬의 원소값도 변경          참조를 하기 때문      #include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    unchar data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};    cv::Mat mat1(3, 4, CV_8UC1, data);  // 3 x 4 형태의 행렬 생성    cv::Mat mat2 = mat1.reshape(0, 1);  // 채널변경 없이 행이 1 개짜리인 행렬 반환 (1 x 12)    mat2.at&lt;uchar&gt;(3) = 100;  // reshape 된 행렬의 3번째 요소를 100으로 변환    std::cout &lt;&lt; \"mat1:\\n\" &lt;&lt; mat1 &lt;&lt; std::endl;  // 원본행렬의 3번째 요소도 100으로 변경    std::cout &lt;&lt; \"mat2:\\n\" &lt;&lt; mat2 &lt;&lt; std::endl;    return 0;}/*mat1:[1, 2, 3, 100; 5, 6, 7, 8; 9, 10, 11, 12]mat2:[1, 2, 3, 100, 5, 6, 7, 8, 9, 10, 11, 12]*/행렬의 행 개수 변경  cv::Mat.resize()의 형태  행렬의 마지막 행 기준으로 행 혹은 행렬 추가          기존 행렬의 행 개수보다 함수의 인자값이 크다면 행 추가      기존 행렬의 행 개수보다 함수의 인자값이 작다면 행 삭제        행 추가의 경우 초기값 지정 가능#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    uchar data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};        cv::Mat mat1(3, 4, CV_8UC1, data);  // 3 x 4 행렬 생성    mat1.resize(5, 100);  // 5 x 4 행렬로 리사이징하며 추가 되는 행렬의 초기값은 100으로 지정    mat1.resize(2, 100);  // 2 x 4 행렬로 리사이징하며 삭제 되는 행렬은 초기값이 필요 없으므로 100은 무시    return 0;}push_back, pop_back  cv::Mat.push_back(), cv::Mat.pop_back()의 형태  push_back은 마지막 행에 행 혹은 행렬을 추가          *this의 열 크기, 데이터 타입이 같아야함        pop_back은 마지막 행 기준 행 혹은 행렬 삭제          *this의 행 크기보다 작아야함      #include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    uchar data[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};    cv::Mat mat(3, 4, CV_8UC1, data);    mat.push_back(cv::Mat(1, 4, CV_8UC1));  // 1 x 4 행렬 (행 벡터) 추가    mat.push_back(cv::Mat(2, 4, CV_8UC1));  // 2 x 4 행렬 추가    mat.pop_back(1);  // 마지막 행 기준 1 x 4 행렬 (행 벡터) 삭제    mat.pop_back(2);  // 마지막 행 기준 2 x 4 행렬 삭제        return 0;}"
  },
  
  {
    "title": "OpenCV 픽셀 참조",
    "url": "/posts/opencv-refer-elem/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-28 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.cv::Mat::at()  가장 직관적이며 행과 열을 나타내는 두 개의 정수를 인자로 받아 해당 위치의 픽셀값을 참조  템플릿으로 재정의해야하므로 항상 자료형을 정의해야함  RGB를 갖는 3채널의 자료형은 cv::Vec3...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.cv::Mat::at()  가장 직관적이며 행과 열을 나타내는 두 개의 정수를 인자로 받아 해당 위치의 픽셀값을 참조  템플릿으로 재정의해야하므로 항상 자료형을 정의해야함  RGB를 갖는 3채널의 자료형은 cv::Vec3b이다#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Vec3b pix = img.at&lt;cv::Vec3b&gt;(100, 100);    // 행렬을 순환해가며 픽셀 값 참조하기    for(int i = 0; i &lt; img.rows; i ++)    {        for(int j = 0; j &lt; img.cols; j++)        {            std::cout &lt;&lt; \"at pixel value(\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \"): \" &lt;&lt; img.at&lt;cv::Vec3b&gt;(i, j) &lt;&lt; std::endl;        }    }  // i, j 값을 통해 행렬 전체를 순환해가며 픽셀값을 반환한다    return 0;}cv::Mat::ptr()  특정 행의 첫 번째 원소의 주소값을 반환  해당 함수는 행 단위로 행렬을 순환한다  cv::Mat::at()과 마찬가지로 3채널의 자료형은 cv::Vec3b이다.          1채널을 갖는 (그레이스케일) 행렬은 uchar.      #include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Vec3b *ptr = img.ptr&lt;cv::Vec3b&gt;(100);  // 행값만 입력하면 해당 행 전체 중 첫 번째 픽셀값의 주소값만 반환    cv::Vec3b ptr100 = ptr[100];  // 100번째 행의 100번째 열의 픽셀값    // 행렬을 순환해가며 픽셀 값 참조하기    for(i = 0; i &lt; img.rows; i++)    {        cv::Vec3b *ptr = img.ptr&lt;cv::Vec3b&gt;(i);  // 행 지정        for(int j = 0; j &lt; img.cols; j++)        {            std::cout &lt;&lt; \"ptr pixel value(\" &lt;&lt; i &lt;&lt; \", \" &lt;&lt; j &lt;&lt; \"): \" &lt;&lt; ptr[j] &lt;&lt; std::endl;        }    }    return 0;}  행 단위의 접근은 ptr이 훨씬 빠르지만 임의의 픽셀 접근은 at이 더 편리하다.cv::MatIterator_  cv::Mat::at()과 cv::Mat::ptr()은 행렬의 범위를 벗어나면 에러 발생  이를 방지하기 위해 OpenCv에선 반복자iterator를 지원  행렬의 begin과 end를 통해 접근하므로 범위를 벗어날 염려가 없음  행렬 전체를 순차적으로 순회하기 때문에 ptr보단 느리고 at보단 자유도가 낮아 사용성이 높지 않음#include \"opencv2/opencv.hpp\"#include &lt;iostream&gt;int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    for(cv::MatIterator_&lt;cv::Vec3b&gt; i = img.begin&lt;cv::Vec3b&gt;(); i != img.end&lt;cv::Vec3b&gt;(); ++i)    {        std::cout &lt;&lt; \"iter pixel value: \" &lt;&lt; *i &lt;&lt; std::endl;    }    return 0;}  i가 begin에서 시작해 end가 아닐 때까지 행렬 전체를 순환한다"
  },
  
  {
    "title": "OpenCV 행렬 범위 참조",
    "url": "/posts/opencv-crop/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-28 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.이미지 crop 하기  cv::Mat 객체에 cv::Rect 등으로 범위를 지정해줘 참조한다  단순히 픽셀 데이터를 참조하는 얕은 복사이므로 새로운 객체를 생성하고 싶다면 clone()을 먼저 사용 후 참조한다#inclu...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.이미지 crop 하기  cv::Mat 객체에 cv::Rect 등으로 범위를 지정해줘 참조한다  단순히 픽셀 데이터를 참조하는 얕은 복사이므로 새로운 객체를 생성하고 싶다면 clone()을 먼저 사용 후 참조한다#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Mat roi = img(cv::Rect(100, 100, 200, 200));  // x, y, width, height    roi = ~roi;  // 해당 영역을 반전시키면 img 도 색상 반전이 됨 (얕은 복사이기 때문)    cv::Mat img2 = cv::imread(\"./path/to/image\");    cv::Mat roi2 = img(cv::Rect(100, 100, 200, 200)).clone();  // clone() 을 통해 객체 복사    roi2 = ~roi2;  // 해당 영역의 색상을 반전시켜도 img2 에는 아무런 영향이 없음 (깊은 복사로 객체를 복사했기 때문)    return 0;}지정한 행, 열의 범위 반환  cv::Mat.rowRange(int x, int y);로 행 범위 지정  cv::Mat.colRange(int x, int y);로 열 범위 지정#include \"opencv2/opencv.hpp\"#inclde &lt;iostream&gt;int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Mat rows = img.rowRange(100, 100);    cv::Mat cols = img.colRange(100, 100);    std::cout &lt;&lt; \"rows: \" &lt;&lt; rows &lt;&lt; std::endl &lt;&lt; std::cout &lt;&lt; \"cols: \" &lt;&lt; cols &lt;&lt; std::endl;    return 0;}// 각 범위에 해당하는 픽셀의 데이터 값들이 출력 된다 (BRG) 값"
  },
  
  {
    "title": "OpenCV 행렬 생성",
    "url": "/posts/opencv-make-mat/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-27 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.행렬 생성행렬 초기화  cv::Mat img(int height, int width, string type)로 초기화하여 생성#include \"opencv2/opencv.hpp\"int main(void){    cv::M...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.행렬 생성행렬 초기화  cv::Mat img(int height, int width, string type)로 초기화하여 생성#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img(360, 640, CV_8UC3);    cv::imshow(\"debug\", img);    cv::waitKey();    cv::destroyAllWindows();    return 0;}  높이 360, 길이 640, RGB 3채널을 갖는 행렬 생성cv::Mat::create#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img2;    img2.cv::Mat::create(cv::Size(640, 360), CV_8UC3);    cv::imshow(\"debug\", img2);    cv::waitKey();    cv::destroyAllWindows();    return 0;}그 외#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img3 = cv::Mat::zeros(360, 640, CV_8UC3);    cv::Mat img4 = cv::Mat::ones(360, 640, CV_8UC3);    cv::Mat img5 = cv::Mat::eyes(360, 640, CV_8UC3);    return 0;}  cv::Mat::zeros(int height, int width, flags): 0 으로 초기화 된 행렬 생성  cv::Mat::ones(int height, int width, flags): 1 로 초기화 된 행렬 생성  cv::Mat::eye(int height, int width, flags): 단위 행렬 (A x E = A 를 만족하는 행렬)"
  },
  
  {
    "title": "OpenCV 행렬 복사",
    "url": "/posts/opencv-copy-matrix/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-27 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.복사 생성자를 통한 행렬 복사  복사 생정자 = 를 통한 행렬 복사  cv::Mat img2 라는 객체를 생성 후 cv::Mat img 객체를 참조-img 를 참조하는 얕은 복사이기 때문에 img 변화에 영향을 받음#in...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.복사 생성자를 통한 행렬 복사  복사 생정자 = 를 통한 행렬 복사  cv::Mat img2 라는 객체를 생성 후 cv::Mat img 객체를 참조-img 를 참조하는 얕은 복사이기 때문에 img 변화에 영향을 받음#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Mat img2 = img;    return 0;}clone() 함수를 통한 행렬 복사  픽셀 데이터를 공유하는 것이 아닌 메모리 공간을 새로 할당 (깊은 복사)  자기 자신과 동일한 cv::Mat 객체를 완전히 새로 만들어 반환#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Mat img2 = img.clone();    return 0;}copyTo() 함수를 통한 행렬 복사  픽셀 데이터를 공유하는 것이 아닌 메모리 공간을 새로 할당 (깊은 복사)  함수 이름에서 알 수 있듯이 원형이 되는 함수를 변수로 받는 객체로 복사한다#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"./path/to/image\");    cv::Mat img2;  // 빈 객체 생성    img.copyTo(img2);  // 빈 객체에 img를 복사    return 0;}"
  },
  
  {
    "title": "OpenCV 클래스",
    "url": "/posts/opencv-class/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv, book review",
    "date": "2023-11-27 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Point_ 클래스  2차원 평면 위에 있는 점의 좌표를 표현하는 템플릿 클래스  x, y 라는 이름의 멤버 변수를 갖고 있음  실제로 어떤 자료형태로 사용할지 정의를 해주어야한다          Point2i (int ...",
    "content": "  해당 포스팅은 OpenCV 4로 배우는 컴퓨터 비전과 머신러닝 (황선규 저)를 보고 공부하며 개인적인 용도를 위해 정리한 글이다.Point_ 클래스  2차원 평면 위에 있는 점의 좌표를 표현하는 템플릿 클래스  x, y 라는 이름의 멤버 변수를 갖고 있음  실제로 어떤 자료형태로 사용할지 정의를 해주어야한다          Point2i (int 형), Point2f (float 형) 등이 존재하며 제일 많이 쓰이는 int 형을 Point 클래스로 오버라이딩 함        (0, 0) 으로 초기화#include \"opencv2/opencv.hpp\"int main(void){    cv::Point pt1;          // pt1 = (0, 0)    pt1.x = 5; pt1.y = 10;  // pt1 = (5, 10)    cv::Point pt2(10, 20);  // pt2 = (10, 20)    return 0;}  좌표에 대한 다양한 연산 가능          Point* 클래스 간 연산, Point* 클래스와 상수 간의 사칙연산, 행렬 연산, bool 연산 등      cv::Point pt3 = pt1 + pt2;  // pt3 = (15, 30)cv::Point pt4 = pt2 * 2;    // pt4 = (20, 40)int d1 = pt1.dot(pt2);      // 250bool b1 = (pt1 == pt2);     // falseSize_ 클래스  영상이나 사각형 영역의 크기를 표현하는 템플릿 클래스  width, height 라는 이름의 멤버 변수를 갖고 있음  Point_ 클래스 와 마찬가지로 자료형을 정의해주어야하며 가장 많이 쓰이는 int 형을 Size 클래스로 오버라이딩  (0, 0) 으로 초기화#include \"opencv2/opencv.hpp\"int main(void){    cv::Size sz1;                    // sz1 = (0, 0)    sz1.width = 5; sz1.height = 10;  // sz1 = (5, 10)    cv::Size sz2(10, 20);            // sz2 = (10, 20)    return 0;}  size 에 대한 다양한 연산 가능          영역을 의미하는 area 멤버 함수를 가짐      int area = sz1.area();  // area = 5 * 10 = 50Rect_ 클래스  사각형의 위치와 크기 정보를 표현하는 템플릿 클래스  x, y, width, height 라는 이름의 멤버 변수를 갖고 있음          x, y 는 사각형의 왼쪽 상단의 지점 (시작 부분)      width, height 는 x, y 로부터 시작 된 크기 정보        (0, 0, 0, 0) 으로 초기화  마찬가지로 int 형을 Rect 클래스로 오버라이딩#include \"opencv2/opencv.hpp\"int main(void){    Rect rc1;                  // (0, 0) 으로 시작하는 (0, 0) 크기의 사각형 (유효하지 않음)    Rect rc2(10, 10, 60, 40);  // (10, 10) 으로 시작하는 (60, 40) 크기의 사각형    return 0;}  Rect_ 클래스의 연산은 Size_ 와 Point_ 클래스로 연산이 가능하다          Point_ 로는 x, y      Size_ 로는 width, height      Rect rc3 = rc1 + Size(50, 40);   // (0, 0) 으로 시작하는 (50, 40) 크기의 사각형Rect rc4 = rc2 + Point(10, 10);  // (20, 20) 으로 시작하는 (60, 40) 크기의 사각형  Rect_ 클래스는 | 와 &amp; 로 논리연산도 수행 가능          | 의 경우 두 사각형이 서로 교차하는 부분      &amp; 의 경우 두 사각형을 포함하는 가장 작은 사각형      RotatedRect 클래스  사각형의 위치, 크기 정보와 회전각도를 표현하는 클래스  center, size, angle 이라는 이름의 멤버 변수를 갖고 있음          center(x, y), size(widht, height), angle        모든 정보를 float 를 사용하여 표현          Point2f, Size2f      #include \"opencv2/opencv.hpp\"int main(void){    RotatedRect rr1(Point2f(40, 30), Size2f(40, 20), 30.f);    return 0;}  RotatedRect 의 네 꼭지점을 얻고 싶다면 RoatedRect::points() 함수 사용  RotatedRect 를 포함하는 최소 크기의 사각형의 좌표는 RotatedRect::boundingRect() 함수 사용cv::Point2f pts[4];rr1.points(pts);for (int i = 0; i &lt; 4; i++){    std::cout &lt;&lt; pts[i] &lt;&lt; std::endl;}"
  },
  
  {
    "title": "선형대수학 (1) - 개론",
    "url": "/posts/linear-algebra-1/",
    "categories": "Math, Linear Algebra",
    "tags": "math, linear algebra, book review",
    "date": "2023-11-23 00:00:00 +0900",
    





    
    "snippet": "  해당 포스팅은 프리드버그의 선형대수학 (5판) 을 보고 공부하며 개인적인 용도를 위해 정리한 글이다.벡터 (vector)  크기와 방향을 모두 가진 물리량.  흔히 화살표로 표현하며 벡터의 크기는 화살표의 길이, 방향은 화살표의 방향으로 표현한다.  어디에 위치해있는지와 관계 없이 크기와 방향이 같으면 동일한 벡터로 간주.벡터의 합 (sum)  두...",
    "content": "  해당 포스팅은 프리드버그의 선형대수학 (5판) 을 보고 공부하며 개인적인 용도를 위해 정리한 글이다.벡터 (vector)  크기와 방향을 모두 가진 물리량.  흔히 화살표로 표현하며 벡터의 크기는 화살표의 길이, 방향은 화살표의 방향으로 표현한다.  어디에 위치해있는지와 관계 없이 크기와 방향이 같으면 동일한 벡터로 간주.벡터의 합 (sum)  두 물리량이 함께 적용할 때 물리량의 크기 뿐 아니라 방향을 함께 고려해야 함.  두 물리량이 결합 될 때 나타내는 효과는 두 벡터를 결합시켜 얻은 합성벡터로 나타낼 수 있음.  합성벡터는 벡터의 합이라고 하며, 두 벡터를 결합시키는 규칙을 벡터 합의 평행사변형 법칙 (pararelleogram law)라고한다.평행사변형의 법칙 (pararelleogram law)  시점이 $P$ 로 일치하는 두 벡터 $x, y$의 합은 점 $P$ 에서 시작하는 벡터이고, 이는 $x$와 $y$ 를 이웃한 변으로 하는 평행사변형의 대각선으로 나타낸다.  평행사변형의 대변은 평행하고 길이가 같으므로 벡터 $x + y$의 종점 $Q$는 점 $P$에서 시작하는 벡터 $x$의 종점에 벡터 $y$의 시점을 이어붙여 도달한 것으로 이해할 수 있다.          같은 방식으로 벡터 $y$의 종점에 벡터 $x$의 시점을 이어붙여도 종점 $Q$에 도달할 수 있다.        점 $P$에 작용한 두 벡터를 합할 때는 한 벡터의 종점에 다른 벡터의 시점을 이어붙이는 방식으로 더한다.  $x, y$ 중 어느 것을 먼저 택하고, 어느 것을 처음 벡터의 종점에 이어붙일지 그 순서는 중요하지 않다.스칼라의 곱 (scalar multiplication)  벡터에 실수를 곱해 벡터의 크기를 확대하거나 축소할 수 있다.  $0$이 아닌 실수 $t$에 대하여 벡터 $tx$의 방향은 $t &gt; 0$일 때, $x$의 방향과 같고, $t &lt; 0$ 일 때 $x$의 방향과 $180^{\\circ}$ 반대이다.벡터의 평행 (pararell)  영이 아닌 두 벡터 $x, y$에 대하여 $y = tx$인 0이 아닌 실수 $t$가 존재할 때, 두 벡터는 평행하다.  방향이 같거나 $180^{/circ}$ 반대인 벡터들은 평행하다.벡터의 합과 스칼라곱의 대수적인 설명  모든 벡터 $x, y$에 대하여 $x + y = y + x$이다.  모든 벡터 $x, y, z$ 에대하여 $(x + y) + z = x + (y + z)$이다.  모든 벡터 $x$ 에 대하여 $x + 0 = x$ 를 만족하는 벡터 $0$ 이 존재한다.  각 벡터 $x$마다 $x + y = 0$를 만족하는 벡터 $y$가 존재한다.  모든 벡터 $x$에 대하여 $1x = x$이다.  모든 실수 $a, b$와 모든 벡터 $x$ 에 대하여 $(ab)x = a(bx)$이다.  모든 실수 $a$와 모든 벡터 $x, y$에 대하여 $a(x + y) = ax + ay$이다.  모든 실수 $a, b$와 모든 벡터 $x$에 대하여 $(a + b)x = ax + bx$이다.직선의 방정식  두 점 $A, B$를 이은 직선 위 임의의 점은 $A$를 시점으로 하는 벡터의 종점이고, 적절한 실수 $t$에 대하여 $tw$이 형태로 표현할 수 있다.          반대로 $A$를 시점으로 하는 벡터 $tw$의 종점은 두 점 $A, B$를 지나는 직선 위의 점이다.        두 점 $A, B$를 지나는 직선의 방정식은 다음과 같다.  $x = u + tw = u + t(v - u)$평면의 방정식  한 직선 위에 있지 않은 세 점 $A, B, C$ 가 존재한다.  시점이 $A$이고 종점이 $B, C$인 두 벡터를 각각 $u, v$라고 가정.  세 점 $A, B, C$로 이루어진 평면 위 임의의 점 $S$는 $A$를 시점으로하고, $su + tv$의 형태인 벡터 $x$의 종점.  벡터 $su$의 종점은 직선 $AB$와 점 $S$를 지나고 직선 $AC$와 평행한 직선의 교점.          같은 방식으로 벡터 $tv$의 종점도 알 수 있다.        세 점 $A, B, C$를 포함하는 평면의 방정식은 다음과 같다.  $x = A + su + tv$"
  },
  
  {
    "title": "Cpp Virtual Function",
    "url": "/posts/cpp-virtual-function/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-11-23 00:00:00 +0900",
    





    
    "snippet": "가상 함수의 필요성 (상속관계에서의 오버라이딩)#include &lt;iostream&gt;class Base{    public:        void BaseFunc() { std::cout &lt;&lt; \"Base Function\" &lt;&lt; std::endl; }};class Derived : public Base{    public: ...",
    "content": "가상 함수의 필요성 (상속관계에서의 오버라이딩)#include &lt;iostream&gt;class Base{    public:        void BaseFunc() { std::cout &lt;&lt; \"Base Function\" &lt;&lt; std::endl; }};class Derived : public Base{    public:        void DerivedFunc() { std::cout &lt;&lt; \"Derived Function\" &lt;&lt; std::endl; }};int main(void){    Base *bptr = new Derived();  // Compile OK    bptr-&gt;DerivedFunc();  // Compiple Error    return 0;}  C++ 컴파일러는 포인터 연산의 가능성 여부를 판단할 때, 포인터의 자료형을 기준으로 판단하지 실제 가리키는 객체의 자료형을 기준으로 판단하지 않는다.  Dervied 는 Base 의 유도클래스이기 때문에 객체포인터로 Dervied 를 가리켜도 Base 에 접근 가능하다.  그러나 Base 형태의 자료형으로 선언한 객체포인터이기 때문에 Dervied 내의 멤버함수는 접근할 수 없다.#include &lt;iostream&gt;class First{    public:        void MyFunc() { std::cout &lt;&lt; \"FirstFunc\" &lt;&lt; std::endl; }};class Second : public First{    public:        void MyFunc() { std::cout &lt;&lt; \"SecondFunc\" &lt;&lt; std::endl; }};class Third : public Second{    public:        void MyFunc() { std::cout &lt;&lt; \"ThirdFunc\" &lt;&lt; std::endl; }};int main(void){    Third *tptr = new Third();    Second *sptr = tptr;    First *fptr = sptr;    fptr-&gt;MyFunc();    sptr-&gt;MyFunc();    tptr-&gt;MyFunc();    delete tprt;    return 0;}// FirstFunc// SecondFunc// ThirdFunc  각 형태에 맞는 객체의 함수들을 호출 (함수의 상속관계에 상관 없다)가상함수 (Virtual Function)  함수 앞에 virtual 로 선언  최상위에서 상속 받는 클래스에서 virtual 로 선언하면 상속하는 자식 클래스들도 자동으로 가상함수화 됨          그러나 가독성 등을 위해 상속하는 클래스에서도 virtual로 선언하는 것을 권장한다      #include &lt;iostream&gt;class First{    public:        virtual void MyFunc() { std::cout &lt;&lt; \"FirstFunc\" &lt;&lt; std::endl; }};class Second : public Fisrt{    public:        virtual void MyFunc() { std::cout &lt;&lt; \"SecondFunc\" &lt;&lt; std::end; }};class Third : public Second{    public:        virtual void MyFunc() { std::cout &lt;&lt; \"ThirdFunc\" &lt;&lt; std::end; }};int main(void){    Third *tptr = new Third();    Second *sptr = tptr;    First *fptr = sptr;    fptr-&gt;MyFunc();    sptr-&gt;MyFunc();    tptr-&gt;MyFunc();    delete tptr;    return 0;}// ThirdFunc// ThirdFunc// ThirdFunc  virtual 로 선언하게 되면 가상함수화 된다  가상함수화 되면 포인터 변수가 자료형을 따지지 않고 실제 가리키는 객체를 참조하여 호출순수 가상함수와 추상클래스 (abstract class)  순수 가상함수는 몸체가 선언 되지 않은 함수를 의미한다  virtual void Func() = 0;의 형태로 표현  추상 클래스는 하나 이상의 순수 가상함수가 정의 된 클래스를 의미한다          객체생성이 불가능한 클래스이다      가상 소멸자 (virtual destructor)  virtual로 선언 된 소멸자를 가상 소멸자라고 한다  오버라이딩 된 함수들의 소멸자들도 순서대로 모두 호출 되어야하기 때문에 최상위 클래스의 소멸자에 virtual로 선언해준다"
  },
  
  {
    "title": "Cpp Object Pointer",
    "url": "/posts/cpp-object-pointer/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-11-23 00:00:00 +0900",
    





    
    "snippet": "객체 포인터  객체의 주소값을 저장하는 포인터 변수.  객체 포인터는 객체 자신뿐만 아니라 해당 객체를 직간접적으로 상속하는 모든 객체들을 지정할 수 있다.#include &lt;iostream&gt;class Person{    public:        void Sleep() { std::cout &lt;&lt; \"Sleep\" &lt;&lt; st...",
    "content": "객체 포인터  객체의 주소값을 저장하는 포인터 변수.  객체 포인터는 객체 자신뿐만 아니라 해당 객체를 직간접적으로 상속하는 모든 객체들을 지정할 수 있다.#include &lt;iostream&gt;class Person{    public:        void Sleep() { std::cout &lt;&lt; \"Sleep\" &lt;&lt; std::endl; }};class Student : public Person{    public:        void Study() { std::cout &lt;&lt; \"Study\" &lt;&lt; std::endl; }};class PartTimeStudent : public Student{    public:        void work() { std::cout &lt;&lt; \"work\" &lt;&lt; std::endl; }};int main(void){    Person *pt1 = new Student();           // Person 을 상속하는 Student 객체 지정    Person *pt2 = new PartTimeStudent();   // Person 을 상속하는 Student 가 상속하는 PartTimeStudent 객체 지정    Student *pt3 = new PartTimeStudent();  // Student 가 상속하는 PartTimeStudent 개체 지정    pt1-&gt;Sleep();    pt2-&gt;Sleep();    pt3-&gt;Study();    delete pt1;    delete pt2;    delete pt3;    return 0;}함수 오버라이딩  상속관계에 있는 클래스 내에서 서로 동일한 이름의 함수가 존재하는 경우, 상속한 클래스의 함수가 호출.함수 오버로딩 vs 함수 오버라이딩  동일한 이름의 함수가 상속 관계에 있는 클래스끼리 존재하더라도 매개변수, 반환값 등이 다르다면 오버로딩이 된다.#include &lt;iostream&gt;#include &lt;cstring&gt;class Employee{    private:        char name[100];    public:        Employee(char *name)        {            strcpy(this-&gt;name, name);        }        void ShowYourName() const        {            std::cout &lt;&lt; \"name: \" &lt;&lt; name &lt;&lt; std::endl;        }};class PermanentWorker : public Employee{    private:        int salary;  // 월 급여    public:        PermanentWorker(char *name, int money)            : Employee(name), salary(money)        {            // empty        }        int getPay() const        {            return salary;        }        void ShowSalaryInfo() const        {            ShowYourName();            std::cout &lt;&lt; \"salary: \" &lt;&lt; getPay() &lt;&lt; std::endl;        }};class TemporaryWorker : public Employee{    private:        int workTime;        int payPerHour;    public:        TemporaryWorker(char * name, int pay)            : Employee(name), workTime(0), payPerHour(pay)        {            // empty        }        void AddWorkTime(int time)  // 일한 시간 추가        {            workTime += time;        }        int getPay() const  // 이 달의 급여        {            return workTime * payPerHour;        }        void ShowSalaryInfo() const        {            ShowYourName();            std::cout &lt;&lt; \"Salary: \" &lt;&lt; getPay() &lt;&lt; std::endl;        }};class SalseWorker : public PermanentWorker{    private:        int salseResult;        double bonusRatio;    public:        SalseWorker(char * name, int money, double ratio)            : PermanentWorker(name, money), salseResult(0), bonusRatio(ratio)        {            // empty        }        void AddSalsesResult(int value)        {            salseResult += value;        }        int getPay() const        {            // 실제 호출 되는 것은 상속 된 PermanentWorker 의 getPay 함수이므로, SalserWorker 의 함수가 호출 되기 위해선 해당 클래스 안에도 같은 이름의 함수가 존재해야한다.            return PermanentWorker::getPay() + (int)(salseResult * bonusRatio);        }        void ShowSalaryInfo() const        {            ShowYourName();            std::cout &lt;&lt; \"Salary: \" &lt;&lt; getPay() &lt;&lt; std::endl &lt;&lt; std::endl;        }};class EmployeeHandler{    private:        Employee *empList[50];        int empNum;    public:        EmployeeHandler() : empNum(0)        {            // empty        }        void AddEmployee(Employee *emp)        {            empList[empNum++] = emp;        }        void ShowAllSalaryInfo() const        {            // for (int i = 0; empNum; i++)            // {            //     empList[i]-&gt;ShowSalaryInfo();            // }        }        void ShowTotalSaraly() const        {            int sum = 0;            // for (int i = 0; i &lt; empNum; i++)            // {            //     sum += empList[i]-&gt;GetPay();            // }            std::cout &lt;&lt; \"salary sum: \" &lt;&lt; sum &lt;&lt; std::endl;        }        ~EmployeeHandler()        {            for (int i = 0; i &lt; empNum; i++)            {                delete empList[i];            }        }};int main(void){    // 직원 관리를 목적으로 설계 된 컨트롤 클래스의 객체생성    EmployeeHandler handler;    // 정규직 직원 등록    handler.AddEmployee(new PermanentWorker(\"KIM\", 1000));    handler.AddEmployee(new PermanentWorker(\"LEE\", 1500));    // 임시직 직원 등록    TemporaryWorker *alba = new TemporaryWorker(\"Jung\", 700);    alba-&gt;AddWorkTime(5);    handler.AddEmployee(alba);    // 영업직 등록    SalseWorker *seller = new SalseWorker(\"Hong\", 1000, 0.1);    seller-&gt;AddSalsesResult(7000);    handler.AddEmployee(seller);    // 이번 달에 지불해야 할 급여의 정보    handler.ShowAllSalaryInfo();    // 이번 달에 지불해야 할 급여의 총합    handler.ShowTotalSaraly();    return 0;}"
  },
  
  {
    "title": "Vector 의 최소, 최대, 평균값 구하기",
    "url": "/posts/cpp-vector/",
    "categories": "",
    "tags": "cpp",
    "date": "2023-11-21 00:00:00 +0900",
    





    
    "snippet": "최소값  *std::min_element(vector.begin(), vector.end());최대값  *std::max_element(vector.begin(), vector.end());평균값  &lt;numeric&gt; 라이브러리 추가  std::accumulate(vector.begin(), vector.end(), 0.0) / vector....",
    "content": "최소값  *std::min_element(vector.begin(), vector.end());최대값  *std::max_element(vector.begin(), vector.end());평균값  &lt;numeric&gt; 라이브러리 추가  std::accumulate(vector.begin(), vector.end(), 0.0) / vector.size();소스코드#include &lt;vector&gt;#include &lt;numeric&gt;int main(void){    std::vector&lt;int&gt; vec;  // int vector 선언    for(int i = 0; i &lt; 5; i++)    {        vec.push_back(i);  // 반복문을 거치며 vector 에 push    }    int minimum = *std::min_element(vec.begin(), vec.end());  // vector 의 최소값 반환    int maximum = *std::max_element(vec.begin(), vec.end());  // vector 의 최대값 반환    double average = std::accumulate(vec.begin(), vec.end(), 0.0) / vec.size();  // vector 의 평균값 반환    return 0;}Reference  멈춤보다 천천히라도  stackoverflow"
  },
  
  {
    "title": "CPP 에서 수행 시간 체크하기",
    "url": "/posts/cpp-time-check/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-11-21 00:00:00 +0900",
    





    
    "snippet": "clock 라이브러리 사용  clock() 는 최대 ms 단위까지 보여줄 수 있다.  반환형은 clock_t.  현재 시간을 반환할 때는 clock() 을 사용한다.  수행시간을 체크한뒤, 그 시간을 초로 환산하고 싶다면 CLOCK_PER_SEC 으로 나눠주면 된다.#include &lt;iostream&gt;#include &lt;time.h&gt;...",
    "content": "clock 라이브러리 사용  clock() 는 최대 ms 단위까지 보여줄 수 있다.  반환형은 clock_t.  현재 시간을 반환할 때는 clock() 을 사용한다.  수행시간을 체크한뒤, 그 시간을 초로 환산하고 싶다면 CLOCK_PER_SEC 으로 나눠주면 된다.#include &lt;iostream&gt;#include &lt;time.h&gt;#include \"opencv2/core.hpp\"#include \"opencv2/imgproc.hpp\"int main(void){    clock_t start, end;    double duration;    start = clock();    cv::Mat img = cv::Mat::zeros(640, 360, CV_8UC3);    cv::rectangle(img, cv::Point(30, 100), cv::Point(100, 200), cv::Scalar(0, 255, 0), 2);    end = clock();    duration = (double)(end - start);    std::cout &lt;&lt; ((duration) / CLOCKS_PER_SEC) &lt;&lt; std::endl;    return 0;}time 라이브러리 사용  time() 은 최대 초단위(s) 까지 보여줄 수 있다.  반환형은 time_t.  현재 시간을 반환할 땐 time(NULL); 을 사용한다.#include &lt;iostream&gt;#include &lt;time.h&gt;#include \"opencv2/core.hpp\"#include \"opencv2/imgproc.hpp\"int main(void){    time_t start, end;    double duration;    start = time(NULL);    cv::Mat img = cv::Mat::zeros(640, 360, CV_8UC3);    cv::rectangle(img, cv::Point(30, 100), cv::Point(100, 200), cv::Scalar(0, 255, 0), 2);    end = time(NULL);    duration = (double)(end - start);    std::cout &lt;&lt; duration &lt;&lt; std::endl;    return 0;}Reference  펭귄과 컴퓨터"
  },
  
  {
    "title": "C++ JSON parser",
    "url": "/posts/cpp-json-parser/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-11-15 00:00:00 +0900",
    





    
    "snippet": "설치  해당 라이브러리의 깃허브 로 이동 후 git clone.  설치 위치로 이동 후 cmakegit clone https://github.com/nlohmann/jsoncd path/to/clonecmaketask.json 수정  \"args\" 에 -I/path/to/installed/json/parser/include 추가{    \"tasks\": ...",
    "content": "설치  해당 라이브러리의 깃허브 로 이동 후 git clone.  설치 위치로 이동 후 cmakegit clone https://github.com/nlohmann/jsoncd path/to/clonecmaketask.json 수정  \"args\" 에 -I/path/to/installed/json/parser/include 추가{    \"tasks\": [        {            \"type\": \"cppbuild\",            \"label\": \"C/C++ cpp build active file\",            \"command\": \"/usr/bin/g++\",            \"args\": [                \"-fdiagnostics-color=always\",                \"-g\",                \"${fileDirname}/**.cpp\",                \"-o\",                \"-I/path/to/installed/json/parser/include\"            ]        }    ]}c_cpp_properties.json 수정  \"includePath\" 에 \"path/to/installed/json/parser/include\" 추가{    \"configurations\": [        {            \"name\": \"Linux\",            \"includePath\": [                \"${workspaceFolder}/**\",                \"path/to/installed/json/parser/include\"            ],            \"defines\": [],            \"compilePath\": \"/usr/bin/g++\",            \"cStandard\": \"c17\",            \"cppStandard\": \"gnu++17\",            \"intelliSenseMode\": \"linux-gcc-x64\"        }    ],    \"version\": 4}사용 방법  #include \"nlohmann/json.hpp 만 추가하면 사용 가능하다.  nlohmann::json 를 통해 인스턴스 생성한다.  기본적인 사용 방법은 python 의 dictionary 와 비슷하다.#include \"nlohmann/json.hpp\"#include &lt;iostream&gt;#include &lt;string&gt;int main(void){    std::string str = \"hello world!\";    nlohmann::json js;    js[\"PI\"] = 3.141592;    js[\"int\"][\"zeroToHundred\"] = 100;    js[\"string\"] = str;    std::cout &lt;&lt; js &lt;&lt;std::endl;  // {\"PI\": 3.141592, \"int\": {\"zeroToHundred\": 100}, \"string\": \"hello world!\"}    return 0;}Reference  json parser official page"
  },
  
  {
    "title": "vscode 가상환경 site-pacakages path 설정",
    "url": "/posts/python-sitepackages/",
    "categories": "Trouble Shooting",
    "tags": "python, trouble shooting",
    "date": "2023-11-02 00:00:00 +0900",
    





    
    "snippet": "문제몇 주 전부터 특정 딥러닝 모델 (YOLOv8)을 predict 할 때마다 segmentation fault 발생으로 predict 가 되지 않았던 문제가 발생했다.관련 모델 공식 홈페이지를 들어가기도해보고 깃허브 도 확인해봤지만 공식 답변은 거의 항상 pip install ultralytics 로 귀결 됐다.몇 번이고 삭제 후 재설치도 진행해보고...",
    "content": "문제몇 주 전부터 특정 딥러닝 모델 (YOLOv8)을 predict 할 때마다 segmentation fault 발생으로 predict 가 되지 않았던 문제가 발생했다.관련 모델 공식 홈페이지를 들어가기도해보고 깃허브 도 확인해봤지만 공식 답변은 거의 항상 pip install ultralytics 로 귀결 됐다.몇 번이고 삭제 후 재설치도 진행해보고 다른 가상환경을 파서 시도도 해봤지만 결과는 항상 동일했다.그렇게 디버깅을 하던 중 import torch 부분에서 현재 내가 설정한 가상환경이 아닌 다른 가상환경의 torch 를 import 하는 것을 확인.그러나 구글링해서 알아낸 settings.json 이나 launch.json 을 수정하는 방법으로는 해결 되지 않았었다.해결python -c \"import sys; print('\\n'.join(sys.path))\"conda deactivateexport PYTHONNOUSERSITE=1conda activate &lt;virtual envrioment name&gt;  python ~ ... 명령어로 sys.path 를 찍어보니 현재 가상환경이 아닌 다른 가상환경도 같이 물어오는 것을 확인  export PYTHONNOUSERSITE=1 명령어로 global packages 사용을 하지 않도록 수정  전체 환경에 적용을 하고 싶다면 .bashrc 파일에 export PYTHONNOUSERSITE=1 를 추가해서 적용  위의 해결책은 일시적인 방법이었으며, 에러 내용을 좀 더 확인해본 결과 CUDA 관련 문제라 유추, CUDA 업데이트 이후 정상작동하는 것을 확인했다.  nvidia-driver 부터 cuda, cudnn 전체 삭제 후 재설치를 진행하였다.Reference  lightman.log"
  },
  
  {
    "title": "Wsl Cuda Install",
    "url": "/posts/wsl-cuda-install/",
    "categories": "Windows, Linux",
    "tags": "windows, linux",
    "date": "2023-10-17 00:00:00 +0900",
    





    
    "snippet": "1. Delete old gpg key  wsl 에서 gpu 를 사용할 땐 윈도우에 설치 된 드라이버를 사용하므로 별도의 드라이버 설치는 안 함.  단, 이 드라이버를 사용하기 위한 wsl 전용의 cuda toolkit 을 설치해야한다.  공식 문서에선 오래 된 gpg key 를 삭제를 권함.    sudo apt-key del 7fa2af80    ...",
    "content": "1. Delete old gpg key  wsl 에서 gpu 를 사용할 땐 윈도우에 설치 된 드라이버를 사용하므로 별도의 드라이버 설치는 안 함.  단, 이 드라이버를 사용하기 위한 wsl 전용의 cuda toolkit 을 설치해야한다.  공식 문서에선 오래 된 gpg key 를 삭제를 권함.    sudo apt-key del 7fa2af80      2. Install specific version cuda toolkit  현 시점 최신 버전은 12.2    wget https://developer.download.nvidia.com/compute/cuda/repos/wsl-ubuntu/x86_64/cuda-wsl-ubuntu.pinsudo mv cuda-wsl-ubuntu.pin /etc/apt/preferences.d/cuda-repository-pin-600wget https://developer.download.nvidia.com/compute/cuda/12.2.0/local_installers/cuda-wsl-ubuntu-12-2-local_12.2.0-1_amd64.debsudo dpkg -i cuda-repo-wsl-ubuntu-12-2-local_12.2.0-1_amd64.debsudo cp /var/cuda-repo-wsl-ubunu-12-2-local/cuda-*-keyring.gpg /usr/share/keyrings/sudo apt-get updatesudo apt-get install cuda -y        2-1. Error occured during install unpack cuda.deb using dpkg -i command    보통의 경우엔 잘 설치가 되겠지만 내 경우엔 sudo dpkg -i ... 하는 부분에서 에러가 발생했다.  터미널 창에 gpg key 를 특정 폴더에 복사하라는 메세지가 출력이 되는데 이를 따라하고 재입력하면서 설치가 완료 됐다.3. Install nvidia-utils  apt-cache search nvidia-utils- 를 이용하여 현재 설치 가능한 util 을 확인한다.  현 시점 최신 버전은 535    sudo apt install nvidia-utils-535      ReferencesLaintZine: 프로그래머 가이드"
  },
  
  {
    "title": "Remote",
    "url": "/posts/remote/",
    "categories": "Windows, Linux",
    "tags": "windows, linux",
    "date": "2023-09-23 00:00:00 +0900",
    





    
    "snippet": "1. Windows 에서 SSH2. Port Forwarding3. WOL4. WSL 연결?",
    "content": "1. Windows 에서 SSH2. Port Forwarding3. WOL4. WSL 연결?"
  },
  
  {
    "title": "WSL 설치",
    "url": "/posts/wsl-install/",
    "categories": "Windows, Linux",
    "tags": "windows, linux",
    "date": "2023-08-21 00:00:00 +0900",
    





    
    "snippet": "설치  윈도우의 cmd 를 연 후 해당 명령어를 입력 해 wsl 을 설치한다.    wsl --install  # wsl 설치wsl --set-defaul-version 2  # wsl 버전의 기본값을 2로 변경        마이크로 소프트 스토어 앱을 연 후 Ubuntu (혹은 본인이 원하는 Linux OS) 를 검색 후 설치한다.  본인이 원하는 ...",
    "content": "설치  윈도우의 cmd 를 연 후 해당 명령어를 입력 해 wsl 을 설치한다.    wsl --install  # wsl 설치wsl --set-defaul-version 2  # wsl 버전의 기본값을 2로 변경        마이크로 소프트 스토어 앱을 연 후 Ubuntu (혹은 본인이 원하는 Linux OS) 를 검색 후 설치한다.  본인이 원하는 OS 의 설치가 끝나면 username 과 password 를 설정한다.설치 된 WSL 확인wsl -l -v  # STATE 에서 Running, Stopped 등이 나옴  해당 명령어로 현재 설치 되어있는 WSL 을 확인할 수 있다.  앞에 * 이 있는 것이 default 이다.  wsl --set-default &lt;Linux OS&gt; 를 통해 현재 설정 된 default wsl 의 OS 를 변경할 수 있다.  wsl --set-version &lt;Linux OS&gt; 2 를 통해 wsl 의 버전을 변경할 수 있다.CMD 에서 WSL 실행  wsl 명령어를 입력하면 default 로 설정 되어있는 wsl 이 실행 된다.ReferenceLainyZine: 프로그래머 가이드"
  },
  
  {
    "title": "MacOS, Ubuntu 환경에서 OpenCV 설치",
    "url": "/posts/cpp-opencv-install/",
    "categories": "CPP, OpenCV",
    "tags": "cpp, opencv",
    "date": "2023-08-03 00:00:00 +0900",
    





    
    "snippet": "MacOS환경  MacBookPro 14  Apple M1 Pro  Ventura 13.1.4설치  brew install opencv 로 설치  /opt/homebrew/Cellar/opencv/4.8.0_1/include 설치 확인  vscode 에서 c_cpp_properties.cpp 수정{  \"configurations\": [    {    ...",
    "content": "MacOS환경  MacBookPro 14  Apple M1 Pro  Ventura 13.1.4설치  brew install opencv 로 설치  /opt/homebrew/Cellar/opencv/4.8.0_1/include 설치 확인  vscode 에서 c_cpp_properties.cpp 수정{  \"configurations\": [    {      \"name\": \"Mac\",      \"includePath\": [        \"${workspaceFolder}/**\",        \"/opt/homebrew/Cellar/opencv/4.8.0_1/include\"      ],      \"defines\": [],      \"macFrameworkPath\": [        \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk/System/Library/Frameworks\"      ],      \"compilerPath\": \"/usr/bin/g++\",      \"cStandard\": \"c11\",      \"cppStandard\": \"c++11\",      \"intelliSenseMode\": \"macos-clang-arm64\"    }  ],  \"version\": 4}  brew install pkg-config 로 패키지 설정 관련 라이브러리 설치  export PKG_CONFIG_PATH=/opt/homebrew/Cellar/opencv/4.8.0_1/lib/pkgconfig 로 환경변수 경로 설정컴파일// main.cpp#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"path/to/file.jpg\")    cv::imshow(\"debug\", img);    cv::waitKey(0);    return 0;}clang++ main.cpp -o main `pkg-config opencv4 --cflags --libs` --std=c++11  상기한 경로의 이미지를 읽어와 보여주는 코드를 작성 후 컴파일한다.tasks.json 수정  tasks.json 은 디버깅, 컴파일 등의 옵션을 지정해주는 설정 파일이다.{  \"version\": \"2.0.0\",  \"tasks\": [    {      \"type\": \"cppbuild\",      \"label\": \"C/C++: clang++ 활성 파일 빌드\",      \"command\": \"/usr/bin/clang++\",      \"args\": [        \"-fdiagnostics-color=always\",        \"${file}\",        \"-o\",        \"${fileDirname}/${fileBasenameNoExtension}\",        \"`pkg-config opencv4 --cflags --libs`\",        \"--std=c++11\"      ],      \"options\": {        \"cwd\": \"${fileDirname}\"      },      \"problemMatcher\": [\"$gcc\"],      \"group\": \"build\",      \"detail\": \"컴파일러: /usr/bin/clang++\"    }  ]}Ubuntu환경  ubuntu 20.04 LTS설치기존 설치 확인  pkg-config --modversion opencv 로 확인하여 버전이 나온다면 설치가 되어있다.  이미 opencv가 설치 되어있고 새로운 버전을 설치하고 싶다면 해당 명령어들로 먼저 삭제.sudo apt-get install libopencv* python-opencvsudo apt-get autoremove패키지 업데이트sudo apt-get updatesudo apt-get upgrade필요 패키지, 모듈 등 설치build-essential, cmake, pkg-config 설치  sudo apt-get install build-essential cmake pkg-config 명령어로 설치  build-essential; c, cpp 컴파일러와 관련 된 라이브러리.  cmake; 컴파일 옵션이나 빌드 된 라이브러리에 포함 시킬 opencv 모듈 설정을 위해 필요하다.  pkg-config; 컴파일 및 링크 시 필요한 라이브러리에 대한 정보를 메타파일로부터 가져오는데 사용한다.추가 패키지 설치# 특정 포맷의 이미지 파일을 불러오거나 저장하기 위해 필요한 패키지sudo apt-get install libjpeg-dev ligtiff5-dev libpng-dev# 특정 코덱의 비디오 파일을 불러오거나 저장하기 위해 필요한 패키지sudo apt-get install ffmpeg libavcodec-dev libavformat-dev libswscale-dev libxvidcore-dev libx264-dev libxine2-dev# 웹캠으로부터 실시간 비디오 캡처를 받기 위해 필요한 패키지sudo apt-get install libv4l-dev v4l-utils# 비디오 스트리밍을 위한 라이브러리sudo apt-get install libgstreamer1.0-dev libgstreamer-plugins-base1.0-dev# 윈도우 생성, 마우스 제어 등의 GUI 를 위해 필요한 패키지 (gtk, qt 등 선택 가능)sudo apt-get install libgtk2.0-dev  # gtk 선택sudo apt-get install libqt4-devsudo apt-get install libqt5-devsudo apt-get install libgtk-3-dev# openGL 지원sudo apt-get install mesa-utils libgl1-mesa-dev libgtkgl2.0-dev libgtkglext1-dev# OpenCV 최적화sudo apt-get install libatlas-base-dev gfortran libeigen3-dev# OpenCV-Python 바인딩sudo apt-get install python3-dev python3-numpyOpenCV 다운로드 및 설치OpenCV, OpenCV contrib 파일 다운로드  OpenCV contrib; 기본 모듈에서 빠진 모듈들과 SURF 등의 모듈들을 사용하기 위해 필요mkdir opencvcd opencvwget -O opencv.zip https://github.com/opencv/opencv/archive/4.8.0.zipunzip opencv.zipwget -O opencv-contrib.zip https://github.com/opencv/opencv_contrib/archive/4.8.0.zipunzip opencv-contrib.zipOpenCV 빌드cd opencv-4.8.0mkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D WITH_TBB=OFF -D WITH_IPP=OFF -D WITH_1394=OFF -D BUILD_WITH_DEBUG_INFO=OFF -D BUILD_DOCS=OFF -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=OFF -D BUILD_TESTS=OFF -D BUILD_PERF_TESTS=OFF -D WITH_QT=OFF -D WITH_GTK=ON -D WITH_OPENGL=OFF -D OPENCV_EXTRA_MODULES_PATH=../../opencv_contrib-4.7.0/modules -D WITH_V4L=ON -D WITH_FFMPEG=ON -D WITH_XINE=ONE -D BUILD_NEW_PYTHON_SUPPORT=ON -D OPENCV_GENERATE_PKGCONFIG=ON -D PYTHON3_PACKAGES_PATH=/usr/lib/python3.10/dist-packages -D PYTHON3_LIBRARY=/usr/lib/x86_64-linux-gnu/libpython3.10.so ../make 명령을 통한 빌드  cpu 코어 갯수를 지정해 빌드한다.  $(nproc) 을 이용하여 본인 cpu 코어 갯수 리턴한다.  time make -j$(nproc)설치 및 설치확인  sudo make install 로 설치.  cat /etc/ld.so.conf.d/* 로 확인한 뒤 파일이 존재하는지 확인한다.  파일이 존재하지 않는다면 sudo sh -c 'echo'/usr/local/lib' &gt; /etc/ld.so.conf.d/opencv.conf' 후 sudo ldconfig 로 생성한다.환경변수 지정  env | grep LD_LIBRARY_PATH 로 확인 후 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/lib 로 설정한다.vscode 설정c_cpp_properties.json 수정{  \"configurations\": [    {      \"name\": \"Linux\",      \"includePath\": [\"${workspaceFolder}/**\", \"/usr/include/opencv4/*\"],      \"defines\": [],      \"comilerPath\": \"/usr/bin/g++\",      \"cStandard\": \"c17\",      \"cppStandard\": \"gnu++14\",      \"intelliSenseMode\": \"linux-gcc-x64\"    }  ],  \"version\": 4}tasks.json 수정{  \"tasks\": [    {      \"type\": \"cppbuild\",      \"label\": \"C/C++: g++ build active file\",      \"command\": \"/usr/bin/g++\",      \"args\": [        \"-fdiangnostics-color=always\",        \"-g\",        \"${file}\",        \"-o\",        \"${fileDirname}/${fileBasenameNoExtension}\",        \"`pkg-config opencv4 --cflags --libs`\",        \"-I/usr/local/include/opencv4\"      ],      \"options\": {        \"cwd\": \"${fileDirname}\"      },      \"problemMatcher\": [\"$gcc\"],      \"group\": {        \"kind\": \"build\",        \"isDefault\": true      },      \"detail\": \"Task generated by Debugger.\"    }  ],  \"version\": \"2.0.0\"}  -I/usr/local/include/opencv4 의 경우 wsl 에서만 필요한 것으로 현재는 확인launch.json 수정  디버깅하기 위해서 필요한 파일{  \"version\": \"0.2.0\",  \"configurations\": [    {      \"name\": \"C/C++: cpp build and debug active file\",      \"type\": \"cppdbg\",      \"request\": \"launch\",      \"program\": \"${fileDirname}/${fileBasenameNoExtension}\",      \"args\": [],      \"stoAtEntry\": false,      \"cwd\": \"${fileDirname}\",      \"enviroment\": [],      \"externalConsole\": false,      \"MIMode\": \"gdb\",      \"setupCommands\": [        {          \"description\": \"Enable pretty-printing for gdb\",          \"text\": \"-enable-pretty-printing\",          \"ignoreFailures\": true        },        {          \"description\": \"Set Disassembly Flavor to Intel\",          \"text\": \"-gdb-set disassembly-flavor intel\",          \"ignoreFailures\": true        }      ],      \"preLaunchTask\": \"C/C++: cpp build active file\",      \"miDebuggerPath\": \"/usr/bin/gdb\"    }  ]}  preLaunchTest 는 tasks.json 에서 label 을 지정하여 해당 조건으로 실행한다는 의미.OpenCV 프로젝트 컴파일  opencv 는 pkg-config 를 실행해야 컴파일 가능  opencv*.pc 파일을 찾아 * 의 숫자가 $2$인지 $4$인지 확인// main.cpp#include \"opencv2/opencv.hpp\"int main(void){    cv::Mat img = cv::imread(\"path/to/file.jpg\")    cv::imshow(\"debug\", img);    cv::waitKey(0);    return 0;}g++ maine.cpp -o main `pkg-config opencv4 --cflags --libs`Trouble Shooting  undefined reference to cv::imread ... 등의 에러가 발생한 경우 sudo apt-get install libopencv-* 로 모듈 재설치Referencehttps://fwanggu-lee.tistory.com"
  },
  
  {
    "title": "클래스 상속 3",
    "url": "/posts/cpp-class-inharitance-3/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-07-01 00:00:00 +0900",
    





    
    "snippet": "클래스 상속을 위한 조건IS-A 관계 성립  ~는 ~이다.  Super class 와 sub class 간에 IS-A 관계가 성립해야한다.#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstring&gt;class Computer{private:\tchar owner[50];p...",
    "content": "클래스 상속을 위한 조건IS-A 관계 성립  ~는 ~이다.  Super class 와 sub class 간에 IS-A 관계가 성립해야한다.#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstring&gt;class Computer{private:\tchar owner[50];public:\tComputer(const char * name)\t{\t\tstrcpy(owner, name);\t}\tvoid Calculate()\t{\t\tstd::cout &lt;&lt; \"요청 내용을 계산합니다.\" &lt;&lt; std::endl;\t}};class NoteBookComp : Computer{private:\tint Battery;public:\tNoteBookComp(const char * name, int initChag)\t\t: Computer(name), Battery(initChag)\t{\t\t// empty\t}\tvoid Charging() { Battery += 5; }\tvoid UseBattery() { Battery -= 1; }\tvoid MovingCal()\t{\t\tif (GetBatteryInfo() &lt; 1)\t\t{\t\t\tstd::cout &lt;&lt; \"충전이 필요합니다.\" &lt;&lt; std::endl;\t\t\treturn;\t\t}\t\tstd::cout &lt;&lt; \"이동하면서 \";\t\tCalculate();\t\tUseBattery();\t}\tint GetBatteryInfo() { return Battery; }};class TabletNoteBook : public NoteBookComp{private:\tchar regstrPenModel[50];public:\tTabletNoteBook(const char * name, int initChag, const char * pen)  // NoteBookComp 와 Computer 의 생성자 둘 다 생성\t\t: NoteBookComp(name, initChag)\t{\t\tstrcpy(regstrPenModel, pen);\t}\tvoid Write(const char * penInfo)\t{\t\tif (GetBatteryInfo() &lt; 1)\t\t{\t\t\tstd::cout &lt;&lt; \"충전이 필요합니다.\" &lt;&lt; std::endl;\t\t\treturn;\t\t}\t\tif (strcmp(regstrPenModel, penInfo) != 0)\t\t{\t\t\tstd::cout &lt;&lt; \"등록 된 펜이 아닙니다.\" &lt;&lt; std::endl;\t\t\treturn;\t\t}\t\tstd::cout &lt;&lt; \"필기 내용을 처리합니다.\" &lt;&lt; std::endl;\t\tUseBattery();\t}};int main(void){\tNoteBookComp nc(\"가나다\", 5);\tTabletNoteBook tn(\"다라마\", 5, \"ISE-241-242\");\tnc.MovingCal();\ttn.Write(\"ISE-241-242\");\treturn 0;}// TabletNoteBook is NoteBookComp// NoteBookComp is Computer // Also, TabletNoteBook is Computer 라는 관계 성립HAS-A 관계  ~는 ~를 포함한다.  Sub class 는 super class 가 지니는 모든 것을 소유한다.  HAS-A 관계는 상속의 조건이 되지만 복합 관계로 이를 대신하는 것이 일반적이다.// HAS-A#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstring&gt;class Gun{private:\tint bullet;public:\tGun(int bnum) : bullet(bnum)\t{\t\t// empty\t}\tvoid Shot()\t{\t\tstd::cout &lt;&lt; \"BBANG!\" &lt;&lt; std::endl;\t\tbullet--;\t}};class Police : public Gun  // Police 라는 클래스가 Gun 을 갖고있음{private:\tint handcuffs;public:\tPolice(int bnum, int bcuff)\t\t: Gun(bnum), handcuffs(bcuff)\t{\t\t// empty\t}\tvoid PutHandCuff()\t{\t\tstd::cout &lt;&lt; \"SNAP!\" &lt;&lt; std::endl;\t\thandcuffs--;\t}};int main(void){\tPolice pman(5, 3);\tpman.Shot();\tpman.PutHandCuff();\treturn 0;}  위의 예제를 다른 방식으로 표현 가능.```cpp#define _CRT_SECURE_NO_WARNINGS#include #include class Gun{private:\tint bullet;public:\tGun(int bnum)\t\t: bullet(bnum)\t{\t\t// empty\t}void Shot(){\tstd::cout &lt;&lt; \"BBANG!\" &lt;&lt; std::endl;\tbullet--;} };class Police{private:\tint handcuffs;\tGun * pistol;  // 클래스 포인터, 상속이 아니라 객체를 생성해서 참조public:\tPolice(int bnum, int bcuff)\t\t:handcuffs(bcuff)\t{\t\tif (bnum &gt; 0)  // bnum 이 1 이상이면 총에 장전\t\t\tpistol = new Gun(bnum);\telse  // 0 이면 총에 아무것도 장전하지 않음\t\tpistol = NULL;}void PutHandcuff(){\tstd::cout &lt;&lt; \"SNAP!\" &lt;&lt; std::endl;\thandcuffs--;}void Shot()  // Gun 클래스를 상속한다면 필요없지만 객체를 만들어 참조하기 때문에 필요{\tif (pistol == NULL)\t\tstd::cout &lt;&lt; \"Hut BBANG\" &lt;&lt; std::endl;\telse\t\tpistol-&gt;Shot();  // 객체로 생성 된 Gun 클래스의 함수 호출}~Police(){\tif (pistol == NULL)\t\tdelete pistol;} };int main(void){\tPolice pman1(5, 3);\tpman1.Shot();\tpman1.PutHandcuff();Police pman2(0, 3);pman2.Shot();pman2.PutHandcuff();return 0; }// HAS-A 관계는 총을 소유하지 않은 경찰을 표현하기 어려우나 Composite 는 NULL 로 초기화해 간단히 해결.// 상속으로 서로 묶인 HAS 관계에서는 클래스를 확장하는 것도 쉽지 않다.```"
  },
  
  {
    "title": "클래스 상속 2",
    "url": "/posts/cpp-class-inhariitance-2/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-07-01 00:00:00 +0900",
    





    
    "snippet": "Protected  Private &gt; Protected &gt; Public 순으로 정보은닉성 강화  일반적인 상황에선 private 와 protected 모두 클래스 외부에서 접근 불가  상속 된 상황이라면 sub class 에서 super class 의 protected 멤버 변수에는 접근 가능          유도 클래스 (Derived c...",
    "content": "Protected  Private &gt; Protected &gt; Public 순으로 정보은닉성 강화  일반적인 상황에선 private 와 protected 모두 클래스 외부에서 접근 불가  상속 된 상황이라면 sub class 에서 super class 의 protected 멤버 변수에는 접근 가능          유도 클래스 (Derived class) 에게만 제한적으로 접근 허용      세 가지 형태의 상속Public  class Derived : public Base  public 보다 접근 범위가 넓은 멤버들을 public 으로 변경시켜 상속한다는 의미.  하지만 public 이 가장 넓은 범위의 접근을 허용하므로 사실상 private 을 제외한 나머지는 그대로 상속한다.Protected  class Dervied : protected Base  Protected 보다 접근 범위가 넓은 멤버는 protected 로 변경시켜 상속한다는 의미.          Protected 보다 넓은 접근 범위의 멤버는 public 이기 때문에 protected 상속을 한 Derived 클래스의 public 멤버는 protected 로 변경 된다.      #include &lt;iostream&gt;using namespace std;class Base{private:\tint num1;protected:\tint num2;public:\tint num3;\tBase() : num1(1), num2(2), num3(3)\t{\t\t// empty\t}};class Derived : protected Base {};  // emptyint main(void){\tDerived drv;\tcout &lt;&lt; drv.num3 &lt;&lt; endl;  // Derived class 에서 public -&gt; protected 가 되므로 외부에서 접근 불가\treturn 0;}Private  class Derived : private Base  protected 와 마찬가지로 private 보다 넓은 접근 범위의 멤버들을 전부 private 으로 변경.  하지만 이 경우엔 모든 멤버들이 접근불가가 되기 때문에 사실상 의미 없는 상속이 되어버린다.cpp 에서는 public 이외의 상속은 다중상속과 같은 경우를 제외하면 잘 없다."
  },
  
  {
    "title": "클래스 상속 1",
    "url": "/posts/cpp-class-inharitance-1/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-06-29 00:00:00 +0900",
    





    
    "snippet": "클래스 상속  cpp 의 상속 예제는 class SubClass : public SuperClass 의 형식  상속한 클래스는 상속 된 클래스의 함수나 변수등에 접근 가능 (only public)          private 은 클래스 외부에서의 접근을 막는 것이므로 비록 상속이 되었을지라도 해당 클래스의 외부에서 접근하는 셈이기 때문      아래...",
    "content": "클래스 상속  cpp 의 상속 예제는 class SubClass : public SuperClass 의 형식  상속한 클래스는 상속 된 클래스의 함수나 변수등에 접근 가능 (only public)          private 은 클래스 외부에서의 접근을 막는 것이므로 비록 상속이 되었을지라도 해당 클래스의 외부에서 접근하는 셈이기 때문      아래 예제에서 UnivStudent 는 Person 의 age, name 에 바로 접근 불가능                  Person      UnivStudent                  상위      하위              기초 (base)      유도 (derived)              슈퍼 (super)      서브 (sub)              부모      자식      #include &lt;iostream&gt;#include &lt;cstring&gt;class Person  // 상속 할 super class 정의{    private:        int age;        char name[50];    public:        Person(int myage, const char * myname)            : age(myage)        {            strcpy(name, myname);        }        void WhatYourName() const        {            std::cout &lt;&lt; \"My name is \" &lt;&lt; name &lt;&lt; std::endl;        }        void HowOldAreYou() const        {            std::cout &lt;&lt; \"I'm \" &lt;&lt; age &lt;&lt; \" years old\" &lt;&lt; std::endl;        }};class UnivStudent : public Person // Person 이란 클래스를 Univstudent 가 public 으로 상속{    private:        char major[50];    public:        UnivStudent(const char * myname, int myage, const char * mymajor)  // 생성자            : Person(myage, myname)  // 상속 한 클래스 초기화        {            stcpy(major, mymagor);        }        void WhoAreYou() const        {            WahtYourName();  // 상속 한 클래스의 함수를 사용 가능            HowOldAreYou();            std::cout &lt;&lt; \"My major is \" &lt;&lt; major &lt;&lt; std::endl;        }};int main(void){    UnivStudent std1(\"name1\", 10, \"major1\");    std1.WhoAreYou();    UnivStudent std2(\"name2\", 11, \"major2\");    std2.WhoAreYou();    return 0;};// MY name is name1// I'm 10 years old// My major is major1// My name is name2// I'm 11 years old// My major is major2상속 클래스 생성자  상속 클래스의 생성은 super 클래스의 생성자가 먼저 생성 되고 그 이후 sub 클래스의 생성자가 생성 된다.상속 클래스 소멸자  상속 클래스의 소멸은 생성과 반대  동일한 구조의 클래스 c1 (super, sub), c2 (super, sub) 가 있을 때          c1 super init -&gt; c2 super init -&gt; c1 sub init -&gt; c2 suv init -&gt; c2 sub dest -&gt; c1 sub dest -&gt; c2 super dest -&gt; c1 super dest 순서      번외.strcpy 를 사용 할 때 new 와 delete 를 사용할 때와 사용하지 않을 때의 차이  동적할당을 언제 사용하느냐에 대한 질문.  char name[50]; 과 char * name; 의 경우처럼 앞의 경우에는 동적할당이 아니기 때문에 new 와 delete 를 사용하지 않으며, 따라서 뒤의 경우에는 함수나 클래스 따위에서 인자를 받아 동적할당을 한다.char name[50];strcpy(name, myname);char * name;name = new char[strlen(myname) + 1];strcpy(name, myname);delete[]name;"
  },
  
  {
    "title": "Tor Browser 를 활용한 외부 IP 접속 selenium 크롤링",
    "url": "/posts/crawling/",
    "categories": "Python",
    "tags": "python, crawling",
    "date": "2023-06-28 00:00:00 +0900",
    





    
    "snippet": "프록시 서버 (Proxy server)  인터넷 접속 시 빠른 엑세스나 안전한 통신을 확보하기 위한 중계서버  클라이언트와 서버의 중간에 위치하고 있어 대신 통신을 받아주는 서버프록시의 종류포워드 프록시 (Forward proxy)  클라이언트 대신 프록시 서버가 목적 서버에 통신해주는 구성.  프록시 서버가 웹서버와 통신을 하므로 클라이언트는 프록시...",
    "content": "프록시 서버 (Proxy server)  인터넷 접속 시 빠른 엑세스나 안전한 통신을 확보하기 위한 중계서버  클라이언트와 서버의 중간에 위치하고 있어 대신 통신을 받아주는 서버프록시의 종류포워드 프록시 (Forward proxy)  클라이언트 대신 프록시 서버가 목적 서버에 통신해주는 구성.  프록시 서버가 웹서버와 통신을 하므로 클라이언트는 프록시 서버만을 통해 정보를 얻게 됨.  어떤 프록시 서버를 경유하도록 할 것인가는 클라이언트가 설정 가능.장점  캐시 저장 (액세스 고속화) ; 프록시 서버에 캐시를 저장하므로 동일 페이지를 리퀘스트 할 때 캐시에 남아있는 정보를 클라이언트에게 전달하여 사이트 접속 속도가 빨라진다.  URL 필터링 ; 사용자 전원의 외부 웹 사이트로의 액세스를 필터링할 수 있다.  클라이언트 접속 우회 ; 클라이언트의 IP 를 마치 다른 나라에서 접속하는 것처럼 우회할 수 있다.리버스 프록시 (Reverse Proxy)  포워드 프록시와 달리 웹서버쪽에 위치하여 클라이언트 접근을 최초로 받아 리퀘스트에 해당하는 웹서버에 배분.  액세스를 프록시 서버에 집약해서 URL 에 따라 request 를 받을 web server 가 바뀌도록 설정할 수 있다.  클라이언트 입장에서는 proxy server 가 web server 와 같은 도작을 하므로 web server 가 여러개 존재하는 것을 은폐할 수 있음.장점  부담 분산 ; proxy server 의 설정을 통해 정적 콘텐츠와 동적 콘텐츠의 보는 곳을 나눔으로써 메모리 사용량의 효율화가 가능하며 로드 밸런스를 병용하면 더욱 분산 가능.  캐시 저장 ; 포워드 프록시와 동일한 기능.  Security, virus 대책 ; 통신시 프록시 서버에 집약 되므로 프록시 서버 내에 security, virus 대책을 구현하여 web server 로부터의 부정적인 액세스, 사용등을 방지 가능.Tor Browser install# tor browser installsudo apt-get updatesudo apt-get install tor# python 으로 tor browser 를 사용하기 위한 stem 설치sudo apt-get install python3-stem# tor password 설정tor --hash-password [password]# tor config 수정vim /etc/tor/torrc    # ControlPort9051 uncomment    # HashedControlPassword uncomment 그리고 위에서 나온 password 붙여넣기 (16:~ 뒤로)# tor restartsudo service tor restart# chrome driver installsudo apt-get install chromium-chromdriverPython crawling code# 필요 라이브러리 임포트import timeimport urllib.requestimport osfrom random import randrangefrom stem import Signalfrom stem.control import Controllerfrom selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.firefox.options import Optionsfrom urllib.parse import quote_plusdef function_check(test_url: str) -&gt; None:    # tor browser 의 기능 동작 체크    with Controller.from_port(port=9051) as controller:        while True:            url = test_url            hostname = \"socks5://127.0.0.1\"            port = \"9050\"            chrome_options = webdriver.ChromeOptions()            chrome_options.add_argument(f\"--proxy-server={hostname + ':' + port}\")                        driver = webdriver.Chrome(options=chrome_options)            driver.get(url)            time.sleep(20)            driver.quit()            controller.authenticate(\"password for tor browser\")            controller.signal(Signal.NEWNYM)            if controller.is_newnym_available() == False:                print(f\"waiting for Tor to Change IP: {controller.get_newnym_wait()} sec\")                time.sleep(controller.get_newnym_wait())# 크롤러 클래스 정의class Crawler:    def __init__(self, url: str, query: str, max_images: int=None) -&gt; None:        self.__mode = \"google\" if \"google\" in url else \"naver\"        self.__url = url if self.__mode == \"google\" else url + quote_plus(query)        self.__query = query        self.__max_images = max_images        options = Options()        options.set_preference(\"network.proxy.type\", 1)        options.set_preference(\"network.proxy.socks\", \"127.0.0.1\")        options.set_preference(\"network.proxy.socks_port\", 9050)        opener = urllib.request.build_opner()        opener.addheaders = [('Users-Agents', 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1941.0 Safari/537.36')]        urllib.request.install_opener(opener)        self.driver = webdriver.Firefox(options=options)        self.driver.get(\"http://icanhazip.com/\")  # 단순 ip 확인용 웹사이트        current_ip = self.driver.page_source.split(\"&lt;pre&gt;\")[-1].split(\"\\n\")[0]  # 현재 접속 IP        # 현재 접속 IP 와 본래의 IP 와 일치한다면 바로 종료        if current_ip == \"###.###.###.###\":            logger.error(f\"changed ip is same as original ip (###.###.###.### == {current_ip})\")            return        self.new_tab()    def new_tab(self) -&gt; None:        # ip 확인용 사이트가 아닌 실제 크롤링을 실시할 탭 열기        tab = self.driver.find_element(By.TAG_NAME, \"body\")        tab.send_keys(Keys.CONTROL + \"t\")        self.driver.get(self.__url)        # 접속 IP 가 바뀌게 되면 뭔가를 Accept 하라는 창이 뜨는데 해당 창의 Accept 태그        try:            self.driver.find_element(By.ID, \"L2AGLb\").click()        except:            pass    def search_image(self) -&gt; None:        # google 의 경우 검색창에 크롤링 할 검색어 입력 후 처리        search_bar = self.driver.find_element(By.NAME, \"q\")        search_bar.send_keys(self.__query)        search_bar.submit()    def load_image(self) -&gt; None:        # 검색 된 이미지 전체 로드        last_height = self.driver.execute(\"return document.body.scrollHeight;\")        while True:            # 아래로 스크롤            self.driver.execute_script(\"window.scrollTo(0, document.body.scrollHeight);\")            time.sleep(randrange(10, 14))  # 페이지가 로드 될 때까지 기다림            new_height = self.driver.execute_script(\"return document.body.scrollHeight;\")            if new_height == last_height:                try:                    # 일정수준 이미지가 로드 되면 show more image 등이 뜨며 클릭버튼이 생기는데 해당 버튼을 클릭해 추가 이미지들을 로드                    more_images = self.driver.find_element(By.CSS_SELECTOR, \".mye4qd\")                    more_images.click()                except:                    break            last_height = new_height    def get_images_google(self) -&gt; None:        # google 에서 크롤링 할 때        time.sleep(randrange(10, 15))        images = self.driver.find_elements(By.CSS_SELECTOR, \".rg_i\")        for idx, img in enumerate(images[:self.__max_images]):            try:                img.click()                time.sleep(randrange(7, 10))                logger.info(f\"{idx} / {len(images)}\")                img_url = self.driver.find_element(By.XPATH, \"/html/body/div[2]/c-wiz/div[3]/div[2]/div[3]/div[2]/div[2]/div[2]/div[2]/c-wiz/div/div/div/div[3]/div[1]/a/img[1]\").get_attribute(\"src\")                urllib.request.urlretrieve(img_url, f\"image/{time.time()}.jpg\")            except Exception as e:                logger.error(e)                pass    def get_images_naver(self) -&gt; None:        # naver 에서 크롤링 할 때        time.sleep(randrange(10, 14))        images = self.driver.find_elements(By.CLASS_NAME, \"_image\")                for idx, img in enumerate(images[:self.__max_images]):            try:                img.click()                time.sleep(randrange(3, 7))                logger.info(f\"{idx} / {len(images)}\")                img_url = self.driver.find_element(By.XPATH, '//*[@id=\"main_pack\"]/section[2]/div/div[2]/div/div/div[1]/div[1]/div/div/div[1]/div[1]/img').get_attribute(\"src\")                urllib.request.urlretrieve(img_url, f\"images/{time.time()}.jpg\")            except Exception as e:                logger.error(e)                pass    def run(self) -&gt; None:        os.makedirs(\"images\", exist_ok=True)        if self.__mode == \"google\":            self.search_image()            self.load_image()            self.get_images_google()        else:            self.load_image()            self.get_images_naver()    def __del__(self) -&gt; None:        self.driver.quit()if __name__ == \"__main__\":    google = Crawler(\"https://www.google.com/imghp?hl=en&amp;tab=ri&amp;authuser=0&amp;ogbl\", \"과자 유통기한\", 100)    google.run()    naver = Crawler(\"https://search.naver.com/search.naver?where=image&amp;section=image&amp;query=\", \"과자 유통기한\", 100)    naver.run()[Reference]  https://real1004zz.tistory.com/m/224"
  },
  
  {
    "title": "friend",
    "url": "/posts/cpp-friend/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-04-24 00:00:00 +0900",
    





    
    "snippet": "friend 선언과 사용  A class 가 B class 를 friend 로 지정하면 B class 는 A class 의 private 변수에 접근 가능  그러나 friend 는 일방적이므로 B class 가 A class 를 friend 로 지정하지 않으면 A class 는 B class 의 private 에 접근 불가  friend 는 class...",
    "content": "friend 선언과 사용  A class 가 B class 를 friend 로 지정하면 B class 는 A class 의 private 변수에 접근 가능  그러나 friend 는 일방적이므로 B class 가 A class 를 friend 로 지정하지 않으면 A class 는 B class 의 private 에 접근 불가  friend 는 class 의 어떤 영역 (private, public) 에서도 지정 가능  friend 는 객체 지향 언어의 정보은닉을 저해하므로 남용하지 않는 것이 좋음  firend 는 전역함수도 지정 가능하며 그렇게 되면 전역함수도 자신이 지정 된 클래스의 private 에 접근 가능해진다  friend 를 지정할 때 클래스나 함수의 선언도 같이 하는 효과가 있다#define _CRT_SECURE_NO_WARNINGS#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Girl;  // 클래스 선언class Boy{private:\tint height;\tfriend class Girl;  // Gril class 를 friend 로 선언public:\tBoy(int len) : height(len)\t{\t\t// empty\t}\tvoid ShowYourFriendInfo(Girl &amp;frn);  // Girl 은 아직 정의 되지 않았지만 위에서 선언을 했기 때문에 컴파일이 가능};class Girl{private:\tchar phNum[20];public:\tGirl(char * num)\t{\t\tstrcpy(phNum, num);\t}\tvoid ShowYourFriendInfo(Boy &amp;frn);\tfriend class Boy;  // Boy class 를 friend 로 선언};void Boy::ShowYourFriendInfo(Girl &amp;frn){\tcout &lt;&lt; \"Her Phone number is \" &lt;&lt; frn.phNum &lt;&lt; endl;  // 이 함수가 실행 되기 위해선 Girl 의 phNum 변수가 필요하기 때문에 클래스보다 뒤에 정의 됨}void Girl::ShowYourFriendInfo(Boy &amp;frn){\tcout &lt;&lt; \"His height is \" &lt;&lt; frn.height &lt;&lt; endl;}int main1(void){\tchar num[20] = \"010-1235-5678\";\tBoy boy(170);\tGirl girl(num);\tboy.ShowYourFriendInfo(girl);\tgirl.ShowYourFriendInfo(boy);\treturn 0;}// friend 선언은 객체 지향 언어의 정보은닉성을 해치므로 남용하지 않는 것이 좋음#include &lt;iostream&gt;using namespace std;class Point;  // class 선언만 함class PointOP  // 함수가 실행 된 시간을 측정{private:\tint opcnt;public:\tPointOP() : opcnt(0)  // private 변수를 0 으로 default 로 초기화\t{\t\t// empty\t}\tPoint PointAdd(const Point&amp;, const Point&amp;);  // 위에서 선언 된 class 의 함수\tPoint PointSub(const Point&amp;, const Point&amp;);  // 위에서 선언 된 class 의 함수\t~PointOP()\t{\t\tcout &lt;&lt; \"Operation times: \" &lt;&lt; opcnt &lt;&lt; endl;  // 실행 시간\t}};class Point  // 선언 된 함수 정의{private:\tint x;\tint y;public:\tPoint(const int &amp;xpos, const int &amp;ypos) : x(xpos), y(ypos)\t{\t\t// empty\t}\tfriend Point PointOP::PointAdd(const Point&amp;, const Point&amp;);  // PointOP class 의 함수를 friend 로 지정\tfriend Point PointOP::PointSub(const Point&amp;, const Point&amp;);  // 동일\tfriend void ShowPointPos(const Point&amp;);  // 전역 함수를 friend 로 지정};Point PointOP::PointAdd(const Point&amp; pnt1, const Point&amp; pnt2){\topcnt++;  // 함수가 호출 될 때마다 상승\treturn Point(pnt1.x + pnt2.x, pnt1.y + pnt2.y);  // friend 로 지정 되었기 때문에 private 변수에 접근 가능}Point PointOP::PointSub(const Point&amp; pnt1, const Point&amp; pnt2){\topcnt++;\treturn Point(pnt1.x - pnt2.x, pnt1.y - pnt2.y);}"
  },
  
  {
    "title": "얕은 복사, 깊은 복사",
    "url": "/posts/cpp-shallow-deep-copy/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-04-22 00:00:00 +0900",
    





    
    "snippet": "얕은 복사  복사가 이루어질 때 포인터 변수가 새로 생성 되지 않고 같은 변수를 가르킴.  클래스의 디폴트 복사 생성자.  메모리에 동적 할당을 한 뒤, 해제를 할 때 복사의 대상이 되었던 객체의 주소가 이미 해제 되어 문제가 발생할 수 있음.#include &lt;iostream&gt;#include &lt;cstring&gt;using namesp...",
    "content": "얕은 복사  복사가 이루어질 때 포인터 변수가 새로 생성 되지 않고 같은 변수를 가르킴.  클래스의 디폴트 복사 생성자.  메모리에 동적 할당을 한 뒤, 해제를 할 때 복사의 대상이 되었던 객체의 주소가 이미 해제 되어 문제가 발생할 수 있음.#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Person  // 클래스 선언{private:  // private 멤버 변수    char * name;    int age;public:  // public 멤버 변수    Person(char * myname, int myage)  // 생성자    {        int len = strlen(myname) + 1;  // 문자열의 길이를 동적으로 받는다        name = new char[len];  // 입력 받은 문자열을 동적 할당        strcpy(name, myname);  // 입력 받은 문자열을 멤버 변수로 복사        age = myage;    }    void ShowPersonInfo() const  // 단순 정보 출력 함수, 단순 출력을 하기 때문에 const 를 사용하여 변수 등의 변화를 방지    {        cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl;        cout &lt;&lt; \"Age : \" &lt;&lt; age &lt;&lt; endl;    }    ~Person()  // 소멸자    {        delete []name;  // 동적 할당 받은 변수를 메모리에서 해제한다        cout &lt;&lt; \"called destructor\" &lt;&lt; endl;  // 클래스가 소멸하면서 출력 될 예정인 문구    }};int main(void){    Person man1(\"Yoo Ju Hyeong\", 31);  // 객체 생성    Person man2 = man1;  // 이미 생성 된 객체를 복사    man1.ShowPersonInfo();  // 출력    man2.ShowPersonInfo();  // 출력    return 0;}// 위 코드는 멤버 대 멤버 복사를 '얕은 복사'를 실시했기 때문에 포인터 변수가 서로 같은 객체를 가르키고 있기 때문에 실제로는 하나의 객체만이 생성 된다// 위 코드에는 복사 생성자를 따로 추가하지 않았기 때문에 디폴트 복사 생성자가 수행이 되었는데, 이를 통해 디폴트 복사 생성자는 '얕은 복사'를 한다고 생각 할 수 있다// man1.name 과 man2.name 이 서로 같은 주소를 가르키고 있기 때문에 delete []name; 이 수행 되는 순간 man2.name 이 먼저 사라지고 man1.name 이 사라질 차례인데// 이미 man1.name 이 참조하고 있어야 할 주소는 삭제가 되었으므로 문제가 발생한다깊은 복사  포인터 변수를 새로 생성하여 복사 한 객체의 변수를 새로운 주소에 저장.  copy.object 의 형태로 사용.#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;class Person{private:    char * name;    int age;public:    Person(char * myname, int myage)    {        int len = strlen(myname) + 1;        name = new char[len];        strcpy(name, myname);        age = myage;    }    Person(const Person&amp; copy) : age(copy.age)  // 복사 생성자를 명시하여 멤버를 복사할 때 포인터 변수를 새로 생성하게끔 함.    {        name = new char[strlen(copy.name) + 1];        strcpy(name, copy.name);    }    void ShowPersonInfo() const    {        cout &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; endl;        cout &lt;&lt; \"Age: \" &lt;&lt; age &lt;&lt; endl;    }    ~Person()    {        delete []name;        cout &lt;&lt; \"called destructor\" &lt;&lt; endl;    }};int main(void){    Person man1(\"Yoo Ju Hyeong\" , 31);    Person man2 = man1;    man1.ShowPersonInfo();    man2.ShowPersonInfo();    return 0;}"
  },
  
  {
    "title": "복사생성자 (2)",
    "url": "/posts/cpp-copy-constructor-2/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-04-22 00:00:00 +0900",
    





    
    "snippet": "복사 생성자 기타메모리 공간의 할당과 초기화가 동시에 일어나는 상황  int num1=num2; 의 경우 num1 이라는 이름의 메모리 공간을 할당과 동시에 num2 에 저장 된 값으로 초기화.```cppint SimpleFunc(int n){  …}int main(void){    int num = 10;    SimpleFunc(num);  // ...",
    "content": "복사 생성자 기타메모리 공간의 할당과 초기화가 동시에 일어나는 상황  int num1=num2; 의 경우 num1 이라는 이름의 메모리 공간을 할당과 동시에 num2 에 저장 된 값으로 초기화.```cppint SimpleFunc(int n){  …}int main(void){    int num = 10;    SimpleFunc(num);  // 호출 되는 순간 n 이 할당 됨과 동시에 초기화}- 위 코드의 경우 매개변수 n 이 할당 됨과 동시에 객체가 초기화 된다.```cppusing namespace std;int SimpleFunc(int n){    ...    return n;  // 반환하는 순간 메모리 공간이 할당 되면서 동시에 초기화}int main(void){    int num = 10;    cout &lt;&lt; SimpleFunc(num) &lt;&lt; endl;  // return 값이 별도의 메모리 공간에 저장이 되어있으므로 cout 으로 출력 가능    return 0;}  위 코드의 경우 return 값이 별도의 메모리 공간에 할당 되고 이 공간에 반환 값이 저장 된다 (반환 값으로 초기화)  위 3가지 경우는 객체를 대상으로 할 때에도 마찬가지."
  },
  
  {
    "title": "복사생성자",
    "url": "/posts/cpp-copy-constructor/",
    "categories": "CPP",
    "tags": "cpp",
    "date": "2023-04-17 00:00:00 +0900",
    





    
    "snippet": "복사생성자cpp 의 초기화int num = 5;int &amp;ref = num;int num(5);int &amp;ref(num);  위 코드의 윗부분과 아랫부분은 결과적으로 동일.class SoSimple{    private:        int num1;        int num2;    public:        SoSimple(int n1...",
    "content": "복사생성자cpp 의 초기화int num = 5;int &amp;ref = num;int num(5);int &amp;ref(num);  위 코드의 윗부분과 아랫부분은 결과적으로 동일.class SoSimple{    private:        int num1;        int num2;    public:        SoSimple(int n1, int n2): num1(n1), num2(n2)        { }        void ShowSimpleData()        {            cout &lt;&lt; num1 &lt;&lt; endl;            cout &lt;&lt; num2 &lt;&lt; endl;        }};int main(void){    SoSimple sim1(15, 20);    SoSimple sim2 = sim1;    sim2.ShowSimpleData();        return 0;}  Sosimple sim2=sim1; 은 초기화를 연상시킨다.  객체 sim2 를 새로 생성하면서 sim1 과 sim2 간의 멤버 대 멤버간의 복사가 일어난다.SoSimple sim2(sim1);  SoSimple 객체를 생성.  객체의 이름은 sim2 라고 지정.  sim1 을 인자로 받을 수 있는 생성자의 호출을 통해 객체생성을 완료.#include &lt;iostream&gt;using namespace std;class SoSimple{private:\tint num1;\tint num2;public:\tSoSimple(int n1, int n2)\t\t: num1(n1), num2(n2)\t{\t\t// empty\t}\tSoSimple(SoSimple &amp;copy)\t\t: num1(copy.num1), num2(copy.num2)\t{\t\tcout &lt;&lt; \"Called SoSimple(SoSimple &amp;copy)\" &lt;&lt; endl;\t}\tvoid ShowSimpleData()\t{\t\tcout &lt;&lt; num1 &lt;&lt; endl;\t\tcout &lt;&lt; num2 &lt;&lt; endl;\t}};int main(void){\tSoSimple sim1(15, 30);\tcout &lt;&lt; \"생성 및 초기화 직전\" &lt;&lt; endl;\tSoSimple sim2 = sim1;\tcout &lt;&lt; \"생성 및 초기화 직후\" &lt;&lt; endl;\tsim2.ShowSimpleData();\treturn 0;}//생성 및 초기화 직전//Called SoSimple(SoSimple &amp;copy)//생성 및 초기화 직후//15//30  해당 코드에서 SoSimple(SoSimple &amp;copy) ... 부분이 복사생성자.  해당 부분은 SoSimple(const SoSimple &amp;copy) ... 로 변경을 해주는 것이 좋다.          복사는 원본을 변경해서는 안 되므로 const 를 붙여준다.        복사생성자에도 디폴트 복사 생성자가 존재하기 때문에 따로 명시해두지 않아도 멤버 대 멤버의 복사를 진행가능하다.복사 생성자의 묵시적 호출을 허용하지 않기.  explicit 를 복사생성자 앞에 적어두면 된다.    explicit SoSimple(const SoSimple &amp;copy)  : num1(copy.num1), num2(copy.num2){  // empty}        explicit 을 사용하면 대입연산자를 이용한 객체의 생성 및 초기화는 불가능해진다.  묵시적 변환이 자주 발생하게 되면 코드의 해석이 힘들어질 수도 있기 때문에 코드의 명확성을 이용해 적절히 사용한다.class AAA{    private:        int num;    public:        AAA(int n): num(n) { }};...AAA obj=3;  /// AAA obj(3);class AAA{    private:        int num;    public:        explicit AAA(int n): num(n) { }};...AAA obj(3);  // 대입연산자는 불가복사 생성자의 호출 시점  기존에 생성 된 객체를 이용해 새로운 개체를 초기화하는 경우.  Call - By - Value 방식의 함수 호출 과정에서 객체를 인자로 전달하는 경우.  객체를 반환하되, 참조형으로 반환하지 않는 경우."
  },
  
  {
    "title": "Epipolar Geometry (에피폴라 기하학)",
    "url": "/posts/epipolar/",
    "categories": "Computer Vision",
    "tags": "cv",
    "date": "2023-04-06 00:00:00 +0900",
    





    
    "snippet": "Epipolar Geometry (에피폴라 기하학)      Stereo Vision 에서 사용 되는 개념.        2개의 pin-hole camera 는 영상 정보에서 depth 정보를 잃어버리게 되는데, 이 때 depth 정보를 얻기 위해 사용.        2개의 카메라가 동일한 객체를 바라본다고 가정했을 때, depth 정보를 생성하기 위...",
    "content": "Epipolar Geometry (에피폴라 기하학)      Stereo Vision 에서 사용 되는 개념.        2개의 pin-hole camera 는 영상 정보에서 depth 정보를 잃어버리게 되는데, 이 때 depth 정보를 얻기 위해 사용.        2개의 카메라가 동일한 객체를 바라본다고 가정했을 때, depth 정보를 생성하기 위한 계산을 수행.  위의 사진을 봤을 때 X 를 바라보는 카메라들이 있다왼쪽 카메라를 기준으로 X 를 바라볼 때 선분 OX 상에 위치한 모든 점들은 평면상으로 같은 지점에 projection 되게 되므로 depth 정보가 사라진다이 때 반대편의 카메라에서 O' 에서 OX 상의 점들을 바라보게 되면 평면상으로 다른 지점에 위치하게 되는데, 이 점들에 대해 삼각측량법을 이용하게 되면 (O, O', X) 삼각형 구도의 꼭대기 부분에 있는 점들에 대해 depth 정보를 취득할 수 있게 된다.Epipole, Epipolar line, Epipolar plane  Epipole; 카메라의 중심인 O, O’ 에서 각 원점에서부터 보여지는 점이 다른 카메라에서 어디에 존재하는지. (두 원점을 잇는 선과 이미지 평면이 만나는 지점 (사진상 e, e'))  Epipolar line; 각 카메라에서 Epipole 들을 이은 선분 (l, l')  Epipolar plane; 두 카메라의 원점과 두 카메라 동시에 바라보는 피사체를 이은 평면 (X, O, O')Essential Matrix, Fundamental Matrix  Epipolar 를 찾기 위해선 2개의 매트릭스가 필요.  Essential Matrix (E); 두 카메라에 대한 위치 정보. Translation 과 Rotation.  Fundametal Matrix (F)          E 와 동일한 정보를 갖고 있지만 픽셀 좌표로 관계를 나타낼 수 있는 정보 추가.      한 카메라에서 찍은 이미지에서 하나의 점을 다른 이미지의 Epipolar line (Epiline) 으로 대응시켜놓은 매트릭스.      두 개의 이미지를 매칭 시켜 계산할 수 있다.      Codeimport cv2import numpy as npclass Epipolar:    def __init__(self, img1, img2):        self.__img1 = img1        self.__img2 = img2        self.__feature_detector = cv2.xfeature2d.SIFT_create()        self.__feature_matcher = cv2.FlannBasedMatcher(dict(algorithm=0, trees=5), dict(checks=50))    def main(self):        kp1, des1 = self.__feature_detector.detectAndCompute(self.__img1, None)        kp2, des2 = self.__Feature_detector.detectAndCompute(self.__img2, None)        matches = self.__feature_matcher.knnMatch(des1, des2, k=2)        pts1 = [kp1[m.queryIdx].pt for m, n in matches if m.distance &lt; 0.5 * n.distance]        pts2 = [kp2[m.trainIdx].pt for m, n in matches if m.distance &lt; 0.5 * n.distance]        pts1 = np.float32(pts1)        pts2 = np.float32(pts2)                F, mask = cv2.findFundamentalMat(pts1, pts2, cv2.FM_LMEDS)        pts1 = pts1[mask.ravel() == 1]        prs2 = pts2[mask.ravel() == 1]        lines1 = cv2.computeCorrespondEpilines(pts2.reshape(-1, 1, 2), 2, F)        lines1 = lines1.reshape(-1, 3)        lines2 = cv2.computeCorrespondEpilines(pts1.reshape(-1, 1, 2), 1, F)        lines2 = lines2.reshape(-1, 3)                return pts1, line1, pts2, lines2if __name__ == '__main__':    img1 = cv2.imread('path/to/img1.png')    img2 = cv2.imread('path/to/img2.png')    epipolar = Epipolar(img1, img2)    pts1, lines1, pts2, lines2 = epipolar.main()  코드에 대한 설명은 빠른 시일내에 작성하도록 하겠다."
  },
  
  {
    "title": "컴퓨터 구조 (6)",
    "url": "/posts/computer-structure-6/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-04-03 00:00:00 +0900",
    





    
    "snippet": "전역 변수와 지역 변수전역변수  함수 외부에서 선언한 변수  함수 내부에서도 접근 가능          변수 호출은 가능하나 변수를 수정하기 위해선 global 이란 명령어가 필요      global_var = 10def func():    global global_var    global_var = 20        return global_var...",
    "content": "전역 변수와 지역 변수전역변수  함수 외부에서 선언한 변수  함수 내부에서도 접근 가능          변수 호출은 가능하나 변수를 수정하기 위해선 global 이란 명령어가 필요      global_var = 10def func():    global global_var    global_var = 20        return global_varprint(global_var)# 20지역변수  특정 지역에서만 접근 가능          특정 지역; 함수 내부, 반복문 내부, 조건문 내부 등        지역변수는 함수의 호출이 끝나거나 반복문이나 조건문이 종료 되는 순간 같이 사라진다값에 의한 전달, 참조에 의한 전달값에 의한 전달 (call by value)  변수가 값에 의해 전달 되었으므로 함수 내부에서 변경 되지 않음.#include &lt;iostream&gt;using namespace std;void change_val(int x, int value){    x = value;    cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \"in change_value\" &lt;&lt; endl;}int main(void){    int x = 30;    change_value(x, 20);    cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \"in main\" &lt;&lt; endl;    return 0;}  값에 의한 전달은 변수의 값만 복사해오는 것이기 때문에 스택 프레임 구조상 함수의 호출이 끝나면 그대로 사라져버린다.  main 함수에서 선언 된 x 의 값은 change_val 함수에 값만 복사가 되어 들어가게 되므로 change_val 함수 내부에서 변경 된 값은 함수의 호출이 끝남과 동시에 사라진다.참조에 의한 전달 (call by reference)  변수가 값이 아닌 참조에 의해 전달 되었으므로 함수 내부에서 변경 가능.#include &lt;iostream&gt;using namespace std;void change_val(int *x, int value){    *x = value;    cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \"in change_val\" &lt;&lt; endl;}int main(void){    int x = 10;    change_val(&amp;x, 20);    cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \"in main\" &lt;&lt; endl;    return 0;}  참조에 의한 전달은 변수의 메모리 주소를 전달하기 때문에 함수 내부에서도 변경이 가능하다.  main 함수에서 선언 된 x 는 change_val 이란 함수에 포인터 형태로 전달 되었으므로 값 자체가 아닌 변수 자체의 메모리 주소가 전달 되었다.  즉, 스택 프레임에서 change_val 의 호출이 끝나도 이미 함수 내에서 x 의 메모리 주소의 값 자체를 바꿨기 때문에 변경사항이 유지 된다.객체 참조에 의한 전달 (call by object reference)  파이썬은 c계열 언어와 다르게 변수를 메모리 공간에 직접 값을 저장하는 것이 아닌 값 객체를 가르킨다.```pythondef change_val(x, value):  x = value  print(f”x: {x} in change_val)if name == “main”:    x = 10    change_val(x, 20)    print(f”x: {x} in main”)```  함수 내부에서만 x 의 값이 바뀌고 main 에서는 x의 값이 변경 되지 않는다.람다 함수  이름이 없는 함수.  다음 행으로 넘어가면 다시 사용할 수 없다.  람다 함수에는 return 과 같은 반환이 없으며 몸체에는 반드시 식이 들어가야한다."
  },
  
  {
    "title": "컴퓨터 구조 (5)",
    "url": "/posts/computer-structure-5/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-03-28 00:00:00 +0900",
    





    
    "snippet": "메모리32비트와 64비트의 의미  데이터를 한 번에 보낼 수 있는 비트의 수          32비트는 한 번에 32비트를, 64비트는 한 번에 64비트를 보낼 수 있다.      한 번에 64비트를 보낼 수 있다는 의미는 메모리주소를 64비트로 표현한다는 의미.      메모리에 우편번호를 매긴다  위에서 말한 것처럼 32비트는 메모리주소를 32비트...",
    "content": "메모리32비트와 64비트의 의미  데이터를 한 번에 보낼 수 있는 비트의 수          32비트는 한 번에 32비트를, 64비트는 한 번에 64비트를 보낼 수 있다.      한 번에 64비트를 보낼 수 있다는 의미는 메모리주소를 64비트로 표현한다는 의미.      메모리에 우편번호를 매긴다  위에서 말한 것처럼 32비트는 메모리주소를 32비트로 표현한다고 하였는데, 32비트는 \\(2^{32} = 4,294,967,296\\) 개를 표현할 수 있다.  $4,294, 967,296$ 은 \\(4 * 1024 * 1024 * 1024\\) 이므로 4GB 를 나타낸다.          예전 32비트 컴퓨터가 램을 4GB 이상 사용하지 못하는 이유이다.        64비트는 $2^{64}$ 이므로 훨씬 많이 사용 가능.변수의 의미  변수는 데이터를 저장할 수 있는 메모리 공간을 의미.  단순한 이름이 아니라 메모리 공간 자체를 의미한다.          숫자와 문자 뿐만 아니라 객체와 함수까지도 담을 수 있다.        변수에 담긴 값이나 가리키는 대상은 언제라도 변경 가능.Python 과 다른 언어와의 변수 선언의 차이C 언어  C 언어 및 대부분의 언어는 int num = 5; 라는 식으로 변수를 선언했을 때 num 이라는 변수에 5 라는 값을 담는다.Python  Python 의 경우에는 num = 5 라는 식으로 선언한 경우 num 이라는 이름에 5 라는 값 객체 를 가리킨다.  C 언어는 선언 된 변수 안에 값이 담겨있고 Python 은 선언 된 변수가 값 객체를 가리킨다.          Python 은 모든 것이 객체다.      "
  },
  
  {
    "title": "컴퓨터 구조 (4)",
    "url": "/posts/computer-structure-4/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-03-21 00:00:00 +0900",
    





    
    "snippet": "색을 표현하는 방법  Red, Green, Blue 를 사용하는 (RGB)  색은 컬러큐브color cube 라는 이름의 정육면체로 표현할 수 있다.  (0, 0, 0) 은 검은색, (1, 1, 1) 은 흰색을 표현.  RGB 은 32비트 (4바이트) 를 사용하는데 4바이트 중 3바이트는 색상을 남은 1바이트는 투명도transparency 를 나타낸다...",
    "content": "색을 표현하는 방법  Red, Green, Blue 를 사용하는 (RGB)  색은 컬러큐브color cube 라는 이름의 정육면체로 표현할 수 있다.  (0, 0, 0) 은 검은색, (1, 1, 1) 은 흰색을 표현.  RGB 은 32비트 (4바이트) 를 사용하는데 4바이트 중 3바이트는 색상을 남은 1바이트는 투명도transparency 를 나타낸다.  RGBa 는 각 RGB 값에 투명도를 의미하는 알파값 (1 ~ 255) 값을 곱한다.색 인코딩  색 인코딩인 16진수를 사용하여 #000000 (검은색) 부터 #FFFFFF (흰색) 까지의 값을 이용한다."
  },
  
  {
    "title": "숫자와 문자가 혼합 된 문자열에서 숫자만 찾기",
    "url": "/posts/find-number-in-string/",
    "categories": "Python, Snippet",
    "tags": "python, snippet",
    "date": "2023-03-20 00:00:00 +0900",
    





    
    "snippet": "Summarya_1, 100_a 등과 같은 문자 + 숫자 조합의 문자열에서 숫자 정보만 반환한다.Source Codeimport reint(''.join(re.findall('\\d', string)))Explanationimport rere 라이브러리를 임포트해준다.re 라이브러니는 정규화 관련 함수들이 들어있는 라이브러리이다.짧은 한 줄의 코드를 굳...",
    "content": "Summarya_1, 100_a 등과 같은 문자 + 숫자 조합의 문자열에서 숫자 정보만 반환한다.Source Codeimport reint(''.join(re.findall('\\d', string)))Explanationimport rere 라이브러리를 임포트해준다.re 라이브러니는 정규화 관련 함수들이 들어있는 라이브러리이다.짧은 한 줄의 코드를 굳이 구분을 짓자면 re.findall('\\d', string), ''.join(), int() 이렇게 3개로 나눌 수 있는데,re.findall('\\d', string)이 코드는 string 이라는 문자열 안에 있는 숫자 ('\\d') 를 전부 찾아내 리스트 형태로 반환한다.''.join()괄호 안에 있는 iterable 한 객체들을 빈칸없이 전부 모아서 합쳐준다.int()str 타입인 숫자만 들어있는 문자열을 int 타입으로 바꿔준다.나는 주로 해당 코드를 sorted() 함수와 엮어 문자와 숫자가 결합 된 파일명들의 리스트들을 정렬하는 데에 사용한다.Resultimport retest_list = ['a_1', 'a_2', 'a_10', '11_a', '2a_', '100', 'a_200']sorted_list_1 = sorted(test_list)sorted_list_2 = sorted(test_list, key=lambda x: int(''.join(re.findall('\\d', x))))print(sorted_list_1)print(sorted_list_2)# 결과# ['100', '11_a', '2a_', 'a_1', 'a_10', 'a_2', 'a_200']# ['a_1', 'a_2', '2a_', 'a_10', '11_a', '100', 'a_200']"
  },
  
  {
    "title": "컴퓨터 구조 (3)",
    "url": "/posts/computer-structure-3/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-03-16 00:00:00 +0900",
    





    
    "snippet": "실수를 표현하는 방법고정소수점 표현법  2진 소수점의 위치를 임의로 정하는 방법  4비트가 있다고했을 때 2비트는 소수점의 오른쪽에 있는 분수를 표현하고 2비트는 왼쪽에 있는 숫자들을 표현하는데 쓸 수 있다.          2비트 = 분수, 2비트 = 정수 표시              정수를 나타내는 비트는 동일하며 분수를 나타내는 비트는 2의 음의...",
    "content": "실수를 표현하는 방법고정소수점 표현법  2진 소수점의 위치를 임의로 정하는 방법  4비트가 있다고했을 때 2비트는 소수점의 오른쪽에 있는 분수를 표현하고 2비트는 왼쪽에 있는 숫자들을 표현하는데 쓸 수 있다.          2비트 = 분수, 2비트 = 정수 표시              정수를 나타내는 비트는 동일하며 분수를 나타내는 비트는 2의 음의 거듭제곱처럼 나타낸다\\[2^1 + 2^0 \\, . 2^{-1} + 2^{-2}\\]              해당 방법은 실수값을 표현하기 위해 필요한 비트가 너무 많기 때문에 범용 컴퓨터에서 사용하는 경우는 드물지만, 디지털 신호 처리 장치 (DSP; Digital Signal Processor) 에선 종종 사용.부동소수점 표현법  넓은 범위의 실수를 2진수로 표현하기 위해 과학적 표기법을 적용.  수를 해석하는 새로운 방법을 도입해서 큰 범위의 수를 표현.          가수mantissa 와 지수exponent 를 통해 표현.    \\[1.2 * 10^{-3} \\; (1.2가 \\, 가수,\\, 10^{-3}가 \\, 지수)\\]    2진수의 지수의 밑은 항상 2로 고정.\\[2^0.2^{-1}\\,* (2^{...2+1+0})\\]  해당 방법은 0을 표현하는 방법이 4가지나 되는 0 표기 중복이 발생하여 비트 낭비가 심하며 모든 수를 표현할 수 없다는 문제를 갖고 있다.IEEE 부동소수점 수 표준  가수와 지수에 대해 각각 부호 비트를 사용.  지수에 대한 부호 비트는 지수의 비트 패턴에 감춰져 있음.  낭비 되는 비트 조합을 최소화하고 반올림을 쉽게하기 위해 여러 가지 트릭을 사용.          정규화normalization ; 가수를 조정해서 맨 앞에 0 이 없게 만드는 것. (이를 위해서 지수도 조정해야함.)      DEC 에서 고안한 가수의 맨 왼쪽 비트가 1 이란 사실을 알고 있으므로 이를 생략하는 방법.        기본정밀도single precision 은 32비트를 사용하며 7비트 정밀도로 $10^{38}$ 의 범위를 표현 가능.          31 번째 (제일 왼쪽) 비트 : S (가수에 대한 부호)      30 ~ 23 비트 : 지수      22 ~ 0 (제일 오른쪽) 비트 : 가수        2배 정밀도double precision 은 64비트를 사용하며 15비트 정밀도로 $10^{308}$ 의 범위를 표현 가능.          63 번째 (제일 왼쪽) 비트 : S (가수에 대한 부호)      62 ~ 52 비트 : 지수      51 ~ 32 (상위 20) 비트 : 가수      31 ~ 0 (하위 32) 비트 : 가수      2진수를 표현하는 다양한 방법BCD  10진수를 표현할 때 4비트를 사용.  12 라는 수를 표현할 때 2진수는 $1100$ 이지만 BCD 로는 $0001$ $0010$ 으로 표현.          앞의 4비트는 십의 자리를 뒤의 4비트는 일의 자리를 표현        디스플레이나 가속도 센서등이 BCD 를 사용하지만 낭비 되는 비트가 너무 많아 현대에는 잘 쓰이지 않음.8진 표현법  밑base number 가 8 ($2^3$) 인 진법.  2진수 비트들을 3그룹으로 묶어서 표현한다.          e.g. $10010111000101100$ 을 표현할 때 3그룹 씩 묶어서 $100$ $101$ $110$ $001$ $010$ $100$ 으로 나눈 후 각자의 수를 계산하여 (4 5 6 1 2 4) 이어 붙인다. → $456124$        아직도 쓰이긴하지만 과거처럼 널리 쓰이진 않음.16진 표현법  밑base number 가 16 ($2^4$) 인 진법.  2진수 비트들을 4그룹으로 표현한다.  최근 컴퓨터 내부가 8비트의 배수를 사용해 만들기 때문.  8의 배수는 4 로는 균일하게 나눠지지만 3 으로는 균일하게 나눠지지 않는다.  16 진수는 0 ~ 9 와 $abcdef$ 까지 사용.          e.g. $11010011111111000001$ 을 표현할 때 4그룹씩 묶어서 $1101$ $0011$ $1111$ $1100$ $0001$ 으로 나눈 후 각자의 수를 계산한다.      $1111$ 은 16 이 되는데 16진수에서 16은 $f$ 로 표현한다.      "
  },
  
  {
    "title": "컴퓨터 구조 (2)",
    "url": "/posts/computer-structure-2/",
    "categories": "Computer Science",
    "tags": "cs",
    "date": "2023-03-15 00:00:00 +0900",
    





    
    "snippet": "비트를 사용해 정수를 표현하기정수 표현실생활의 우리가 주로 사용하고 있는 수는 10 진수demical number이다.0 ~ 9 까지를 한 자리에 나타낼 수 있으며  9를 넘는 수는 10 을 곱하여 다시 시작한다.이때 자릿수가 커짐에 따라 10 의 거듭제곱으로 커지게 되며, 지수 부분이 적용 될 밑수base-number 가 10 이기 때문에 10진수라...",
    "content": "비트를 사용해 정수를 표현하기정수 표현실생활의 우리가 주로 사용하고 있는 수는 10 진수demical number이다.0 ~ 9 까지를 한 자리에 나타낼 수 있으며  9를 넘는 수는 10 을 곱하여 다시 시작한다.이때 자릿수가 커짐에 따라 10 의 거듭제곱으로 커지게 되며, 지수 부분이 적용 될 밑수base-number 가 10 이기 때문에 10진수라는 이름이 붙여졌다.이와 마찬가지로 2진수는 0 ~ 1 까지를 한 자리에 나타낼 수 있는 셈법이며 1 을 초과하는 수를 나타낼 땐 2 를 곱하여 다시 시작한다.자릿수가 바뀔 때마다 2 의 거듭제곱순으로 커지게 되며, 밑수가 2 이기 때문에 2 진수라는 이름이 붙었다.  10진수: \\(... 10^5 + 10^4 + 10^3 + 10^2 + 10^1 + 10^0\\)  2진수: \\(... 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0\\)\\(5,028\\) 이라는 수를 표현할 때,10 진수는 \\(5 * 10^3 + 0 * 10^2 + 2 * 10^1 + 8 * 10^0\\)2 진수는 $1 * 2^{12} + 0 * 2^{11} + 0 * 2^{10} + 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 0 * 2^6 + 1 * 2^5 + 0 * 2^4 + 0 * 2^3 + 1 * 2^2 + 0 * 2^1 + 0 * 2^0$10 진수로는 네 자리, 2 진수로는 13자리 (13bit) 가 된다.각 진법의 숫자 개수는 표현할 수 있는 값의 범위를 결정하는데 0 ~ 99 사이의 100가지 다른 수는 10 진수 숫자 2개로 표현 가능하다.마찬가지로 2 진수에서도 비트의 개수로 표현할 수 있는 값의 범위를 정하는데, 예를 들면 2 비트는 0 ~ 3 까지의 수를 표현할 수 있다.2 진수에서 가장 오른쪽에 있는 비트는 가장 작은 유효 비트 (LSB; Least Significant Bit),가장 왼쪽에 있는 비트는 가장 큰 유효 비트 (MSB; Most Significant Bit) 라고 한다.LSB 가 변경 되면 숫자가 가장 적게 변화하고 MSB 가 변경 되면 숫자가 가장 크게 변화하기 때문이다.위에서 본 $5,028$ 는 13bit 라는 것을 알았는데, 이를 16비트 2진수로 표현하면$0 0 0 1 0 0 1 1 \\, 1 0 1 0 0 1 0 0$ 로 표현 할 수 있는데, 이 때 16 자리만큼 채우기 위해 앞에 0 을 붙이는 것을 리딩 제로leading zero 라고 한다.$05,028$ 과 비슷한 의미이며 컴퓨터는 메모리를 할당할 때 미리 정해진 수의 비트를 한 덩어리로 사용하도록 만들어졌기 때문이다. (이 덕분에 어떤 값을 표현하는데 필요한 최소한의 비트 수보다 더 많은 비트를 추가할 수 있다.)2진수 덧셈2 진수의 덧셈은 10 진수의 덧셈과 비슷하게 LSM 부터 MSB 쪽으로 연산하며 결과가 1보다 크면 1을 다음 자리로 올린다.예를 들면 $1 1$ 과 $1 0$ 의 덧셈은 $1 0 1$ 이 된다.이를 10 진수로 풀이해보면 $1 1$ 은 10 진수로 $(1 * 2^1) + (1 * 2^0) = 3$ 이고 $1 0$ 은 $(1 * 2^1) + (0 * 2^0) = 2$ 이기 때문에 $5$ 가 된다.$5$ 을 2 진수로 표현하면 $(1 * 2^2) + (0 * 2^1) + (1 * 2^0) = 5$ 가 된다.2 진 덧셈을 논리연산으로 풀이하면 다음과 같다.            A      B      A AND B      A + B      A XOR B      A      B                  0      0      0      00      0      0      0              0      1      0      01      1      0      1              1      0      0      10      1      1      0              1      1      1      10      0      1      1      A 와 B 의 합연산은 A XOR B 의 값과 같으며 1, 1 인 경우에 1 XOR 1 이 0 인데 이는 두 비트를 더한 결과에서 원래의 위치에 넣을 값과 같다.  비트의 덧셈 연산 중 MSB 에서 올림이 발생했을 때, 오버플로over flow 가 발생한다.음수 표현부호비트 표기법특정한 개수의 비트가 있을 때 MSB 를 부호로 표현한다.0 일 때 양수, 1 일 때 음수.$0001(+1) + 1001(-1)$ 을 계산하면 $1010(-2)$ 이 된다.우리가 의도한 바는 $(+1) + (-1) = 0$ 이 되는 것이었는데 실제로는 $-2$ 가 되었다.이러한 문제점 때문에 부호비트를 통해 음수를 표현하는 것은 잘 쓰이질 않는다.1의 보수one’s complement양수의 모든 비트를 뒤집는 방법이며, 부호비트 표기법과 비슷하게 부호비트와 나머지로 나눈다.1 의 보수라는 문맥에서는 NOT 연산을 통해 보수를 얻는다.그러나 위의 표기법도 부호비트 표기법과 마찬가지로 덧셈 연산이 쉽지 않기 때문에 현대 컴퓨터에서는 거의 쓰이질 않는다.2의 보수two’s complement$+ 1$ 을 했을 때 0 이 되는 비트 패턴을 찾고 $-1$ 이라고 표현을 하는 것이다.4비트 수의 경우 $+1$ 의 경우 $0001$ 인데 $1111$ 을 $0001$ 에 더하면 $0000$ 이 된다.이 때 $1111$ 을 $-1$ 패턴으로 사용한다.2의 보수는 모든 비트에 NOT 연산을 수행하고 거기에 1 을 더하는 것이다.이 때 MSB 를 넘어가는 값은 버린다.예를 들어보면 $0010(2)$ 를 NOT 연산하면 $1101$ 이 되고 이 때 1을 더하면 $1110$ 이 되며 이를 $-2$ 이라고 하면 된다.  2의 보수는 1의 보수와 부호비트 표기법과 다르고 0 을 표기하는 방법이 하나이기 때문에 현대의 컴퓨터에서는 대부분 2의 보수를 많이 사용한다."
  },
  
  {
    "title": "배치리스트 만들기",
    "url": "/posts/make-batch-list/",
    "categories": "Python, Snippet",
    "tags": "python, snippet",
    "date": "2023-03-14 00:00:00 +0900",
    





    
    "snippet": "Summary파일명이나 이미지 등이 들어가있는 리스트와 배치 사이즈를 입력 받아 그 리스트를 배치 단위로 잘라주는 함수이다.Source Codedef make_batch_list(self, file_list: List[], batch_size: int) -&gt; List[]:    result_list = []    for idx in range(0...",
    "content": "Summary파일명이나 이미지 등이 들어가있는 리스트와 배치 사이즈를 입력 받아 그 리스트를 배치 단위로 잘라주는 함수이다.Source Codedef make_batch_list(self, file_list: List[], batch_size: int) -&gt; List[]:    result_list = []    for idx in range(0, len(file_list), batch_size):        if idx + batch_size &lt; len(file_list):            result_list.append(file_list[idx:idx+batch_size])        else:            result_list.append(file_list[idx:])    return result_listExplenationdef make_batch_list(self, file_list: List[], batch_size: int) -&gt; List[]:input data 로 잘라 줄 대상이 될 리스트와 잘라 줄 단위인 배치 사이즈를 지정한다.result_list = []배치 단위로 잘린 결과를 담을 리스트를 선언한다.for idx in range(0, len(file_list), batch_size):배치 사이즈 단위로 반복문을 수행한다.(for in range(a, b, c) 에서 a 는 start, b 는 end, c 는 step 을 뜻한다.)if idx + batch_size &lt; len(file_list):    result_list.append(file_list[idx:idx+batch_size])현재 파일 위치 + 배치 사이즈의 크기가 리스트의 최대 길이를 넘지 않는다면 그 범위만큼 잘라 추가해준다.else:  # == idx + batch_size &gt; len(file_list)    result_list.append(file_list[idx:])반대로 현재 파일 위치 + 배치 사이즈의 크기가 최대 길이를 넘었다면 현재 파일 위치에서 리스트의 끝까지 추가한다.return result_list모든 리스트를 순회해서 배치 단위로 잘라준 리스트를 반환한다.Resulttest_list = [i for i in range(10)]batch_list = make_batch_list(test_list, 3)batch_list2 = make_batch_list(test_list, 4)print(batch_list)print(batch_list2)# 결과# [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]# [[0, 1, 2, 3], [4, 5, 6, 7], [8, 9]]"
  },
  
  {
    "title": "컴퓨터 구조 (1)",
    "url": "/posts/computer-structure-1/",
    "categories": "Computer Science",
    "tags": "",
    "date": "2023-03-13 00:00:00 +0900",
    





    
    "snippet": "컴퓨터 내부의 언어 체계  언어란? 기호의 집합으로 인코딩encoding 된 것을 당사자들간 모두 같은 문맥context 로 의사소통하는 것비트bit  binary + digit 의 합성어  0, 1 을 나타내는 이진법 사용  기호는 주관적이므로 켜짐 / 꺼짐, 낮 / 밤 등이 될 수 있다논리연산logical operation  다른 비트들이 표현하는...",
    "content": "컴퓨터 내부의 언어 체계  언어란? 기호의 집합으로 인코딩encoding 된 것을 당사자들간 모두 같은 문맥context 로 의사소통하는 것비트bit  binary + digit 의 합성어  0, 1 을 나타내는 이진법 사용  기호는 주관적이므로 켜짐 / 꺼짐, 낮 / 밤 등이 될 수 있다논리연산logical operation  다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작불리언 대수boolean  비트에 사용할 수 있는 연산 규칙의 집합      일반 대수와 마찬가지로 결합 법칙, 교환 법칙, 분배 법칙 등을 적용 가능    NOT: 논리적 반대를 의미, 참 -&gt; 거짓, 거짓 -&gt; 참으로 연산  AND: 둘 이상의 비트에 작용          연산의 대상이 되는 비트 참 인 경우에만 참        OR: 둘 이상의 비트에 작용          연산의 대상이 되는 비트 중 하나라도 참인 경우에 참        XOR (ExclusiveOR): 둘 이상의 비트에 작용          연산이 되는 대상의 비트 중 하나 이상의 비트가 참일 때 참      연산이 되는 대상의 비트 중 모든 비트가 참인 경우엔 거짓        XOR 연산은 (a OR b) AND (NOT(a AND b)) 로 만들 수 있다드모르간의 법칙  불리언 대수에 적용할 수 있는 법칙            a      b      a AND b      NOT a      NOT b      NOT a OR NOT b      NOT (NOT a OR NOT b)                  F      F      F      T      T      T      F              F      T      F      T      F      T      F              T      F      F      F      T      T      F              T      T      T      F      F      F      T      위 표에서 봤을 때 AND 연산 또한 NOT 과 OR 을 이용해 만들 수 있다드모르간 법칙은 입력받은 비트의 연산을 최소화하기 위해서 사용될 수 있다"
  },
  
  {
    "title": "우분투 환경 세팅 (3)",
    "url": "/posts/ubuntu-env-setting-3/",
    "categories": "Ubuntu, Settings",
    "tags": "ubuntu, settings, git, vscode",
    "date": "2023-03-12 00:00:00 +0900",
    





    
    "snippet": "설치 환경  Geforece 3090  Ubuntu 20.04 LTSGit 설치sudo apt-get install git 명령어로 설치 가능하다git --version 혹은 git -V 으로 설치 여부를 확인한 뒤 git config 명령어로 설정을 완료한다git config --user.name {user_name}git config --user....",
    "content": "설치 환경  Geforece 3090  Ubuntu 20.04 LTSGit 설치sudo apt-get install git 명령어로 설치 가능하다git --version 혹은 git -V 으로 설치 여부를 확인한 뒤 git config 명령어로 설정을 완료한다git config --user.name {user_name}git config --user.email {user_email}git config --list마지막 줄 명령어로 입력한 config 가 제대로 적용 되었는지 확인한다VScode 설치VScode official site 으로 접속해 자신의 os 에 맞는 실행 파일 .deb 을 받는다터미널에 다운로드 경로로 이동해 sudo apt install ./{file_name} 를 입력하여 설치를 진행한다터미널을 재실행 한 뒤 code 를 입력하면 vscode 가 켜진다 (혹은 그냥 vscode 를 검색해서 실행시킬 수 있다)"
  },
  
  {
    "title": "우분투 환경 세팅 (2)",
    "url": "/posts/ubuntu-env-setting-2/",
    "categories": "Ubuntu, Settings",
    "tags": "ubuntu, settings, anaconda",
    "date": "2023-03-11 00:00:00 +0900",
    





    
    "snippet": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSAnaconda 설치Anaconda official site 를 통해 자신의 os 에 맞는 버전을 선택해 다운로드 받는다파일이 다운로드 된 경로로 이동해 설치를 진행하기 전 sha256sum {file_name} 명령어를 통해 데이터 무결성을 검사한다해당 명령어를 입력하면 해시값이 나오...",
    "content": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSAnaconda 설치Anaconda official site 를 통해 자신의 os 에 맞는 버전을 선택해 다운로드 받는다파일이 다운로드 된 경로로 이동해 설치를 진행하기 전 sha256sum {file_name} 명령어를 통해 데이터 무결성을 검사한다해당 명령어를 입력하면 해시값이 나오는데 이를 복사한뒤 Hashes for all files 접속해 복사한 해시값이 있는지 확인한다해시값이 있는지 확인이 되면 bash {file_name} 혹은 ./{file_name} 를 통해 .sh 파일을 실행해 설치를 진행한다파일을 실행하면 Terms and conditions 등이 지나간 뒤 설치 경로를 지정해주고 (enter 를 누르면 default, 다른 경로 지정은 직접 입력) &lt;/br&gt;설치를 좀 더 진행하면 [yes|no] 를 선택하라는 문구가 나오는데 yes 를 선택한다(no 를 선택하면 아나콘다 환경에서 쉘 스크립트를 수정할 수 없다)Anaconda Prompt 사용 설정아나콘다를 설치하더라도 바로 conda 명령어 (e.g. conda create, conda env list, conda instal, …) 가 먹히지 않는다ananconda prompt 를 사용하기 위해선 vim ~/.bashrc 를 통해 맨 아래줄에 해당 명령어를 추가해준다  export PATH=~/ananconda3/bin:~/ananconda3/condabin:$PATHsource ~/.bashrc 입력 후 터미널을 껐다 키면 앞에 (base) 가 붙는다Anaconda prompt 자동 실행 옵션 해제conda config --set auto_activate_base False 를 터미널에 입력 후 껐다키면 (base) 가 사라진다(터미널 실행 시 자동으로 Anaconda prompt 가 실행 되는 것을 방지)anaconda prompt 를 실행하기 위해선 conda acitvate 를 입력하면 앞에 켜지고 conda deactivate 를 입력하면 꺼진다"
  },
  
  {
    "title": "우분투 환경 세팅 (1)",
    "url": "/posts/ubuntu-env-setting-1/",
    "categories": "Ubuntu, Settings",
    "tags": "ubuntu, settings, cuda, cudnn",
    "date": "2023-03-09 00:00:00 +0900",
    





    
    "snippet": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSpre-setting그래픽 드라이버를 설치하기 전 필요한 패키지들을 먼저 설치해준다sudo apt-get update &amp;&amp; sudo apt-get upgrade -ysudo apt-get install openssh-serversudo apt-get install net-...",
    "content": "설치 환경  Geforce 3090  Ubuntu 20.04 LTSpre-setting그래픽 드라이버를 설치하기 전 필요한 패키지들을 먼저 설치해준다sudo apt-get update &amp;&amp; sudo apt-get upgrade -ysudo apt-get install openssh-serversudo apt-get install net-toolssudo apt-get install build-essentialsudo apt-get install manpages-devgcc -V 으로 gcc 컴파일러 설치 확인 (이후에 CUDA 설치할 때 필요)그래픽 드라이버 확인 및 설치터미널에 ubuntu-drivers devices 를 입력하면 현재 그래픽카드와 os 에 맞는 그래픽 드라이버들이 출력 된다sudo apt-get install nvidia-driver-autoinstall 는 권장설치 sudo apt-get install nvidia-driver-{version} 는 본인이 원하는 버전을 수동으로 설치한다나는 515 버전을 설치했다 sudo apt-get install nvidia-driver-515CUDA 설치cuda-toolkit-archive 링크로 접속해 원하는 버전의 자신의 os 에 맞는 CUDA 를 받는다나는 Linux -&gt; x86_64 -&gt; Ubuntu -&gt; 20.04 -&gt; runfile(local) 을 통해 파일을 받았다.deb 파일로도 받을 수 있고 network 를 통해서 설치할 수 있다설치 방법은 nvidia 홈페이지에 나와있는 대로 실행하면 된다CUDA 11.7, 그래픽드라이버 515 기준 wget https://developer.download.nvidia.com/compute/cuda/11.7.0/local_installers/cuda_11.7.0_515.43.04_linux.runcd ~/Downloadssudo sh cuda_11.7.0_515.43.04_linux.run참고로 파일을 실행한 다음 설치 할 파일들을 선택할 수 있는 창이 뜨는데, 이 때 그래픽 드라이버는 위에서 이미 설치를 했기 때문에 선택을 해제하고 설치를 마저 진행하면 된다cuDNN 설치cudnn-archive 링크로 접속해 본인의 상황에 맞는 cuDNN 을 다운로드 받는다nvidia 계정을 요구하므로 가입하고 진행하면 된다다운로드가 완료 되면 파일이 있는 위치로 가 압축파일을 해제한다tar.gz 파일은 tar xvzf {file_name} 명령어로tar 파일은 tar xvf {file_name} 명령어로 해제한다압축을 해제하면 해당 폴더 안으로 들어간뒤 폴더 내의 내용물들을 전부 CUDA 가 설치 된 위치에 복사하면 된다같은 이름의 파일이 있다고 할텐데 replace 시켜주면 된다sudo cp ./{cuDNN dir}/include/* /usr/local/{cuda dir}/includesudo cp ./{cuDNN dir}/lib64/* /usr/local/{cuda dir}/lib64sudo chmod a+r /usr/local/{cuda dir}/lib64/libcudnn*환경변수 설정위에서 모든 파일의 설치 및 복사가 완료 되었으면 다음은 컴퓨터의 어떤 경로에서든지 CUDA 와 cuDNN 을 참조할 수 있도록 환경 변수를 설정한다vi 이나 vim 편집기로 파일을 열어주면 되는데, 없다면 sudo apt-get install vim 등을 이용하여 먼저 설치해준다vim ~/.bashrc 로 파일을 열어준 뒤export PATH=/usr/local/{cuda-version}/bin${PATH:+:${PATH}}export LD_LIBRARY_PATH=/usr/local/cuda/lib64:${LD_LIBRARY_PATH:+:${LD_LIBRARY_PATH}}를 파일 제일 아래에 추가해 준다(vim 에서 문서를 처음 편집하려고 할 때 아무것도 입력이 안 되는데 이는 vim 의 명령어 모드이기 때문이다. i, o, a 등의 명령어로 입력 모드로 변경한 뒤 입력해주고 esc 를 눌러 다시 명령어 모드로 바꾸고 :wq 를 입력하여 최종적으로 입력 내용을 저장한다)source ~/.bashrc 를 입력하여 해당 내용이 적용 될 수 있도록 한다설치 확인nvidia-smi 와 nvcc -V 혹은 nvcc --version 을 입력하여 그래픽 드라이버와 CUDA 가 잘 설치 되었는지를 확인하면 된다참고로 nvidia-smi 에서 출력 되는 드라이버는 현재 설치 된 드라이버가 아닌 최신 드라이버이므로 혼동하면 안 된다"
  }
  
]

